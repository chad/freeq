<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Architecture Decisions: Protocol Boundary and Moderation — freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">← Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>Architecture Decisions: Protocol Boundary and Moderation</h1>
<h2>1. The Two-Tier Problem</h2>
<p>The moment we add capabilities that legacy clients can&#39;t see — DID-based identity, CRDT-synced state, iroh transport, E2EE channels — we create two tiers of experience. This is the central design tension.</p>
<h3>Our Position</h3>
<p><strong>Two tiers are inevitable and correct.</strong> The question is whether the degradation is graceful.</p>
<p>Think of it like HTTP/1.1 and HTTP/2. Both work. One gets more features. Neither breaks the other. The protocol boundary must be explicit, and the degradation must be clean.</p>
<h3>Where We Draw the Line</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Legacy Client</th>
<th>Modern Client</th>
<th>Mechanism</th>
</tr>
</thead>
<tbody><tr>
<td>Connect, join, chat</td>
<td>✓</td>
<td>✓</td>
<td>IRC protocol</td>
</tr>
<tr>
<td>Nick registration</td>
<td>Server-local only</td>
<td>DID-bound, portable</td>
<td>SASL ATPROTO-CHALLENGE</td>
</tr>
<tr>
<td>Identity in WHOIS</td>
<td>nick!user@host</td>
<td>+ DID + AT handle + iroh ID</td>
<td>IRCv3 CAP</td>
</tr>
<tr>
<td>E2EE channels</td>
<td>See ciphertext <code>ENC1:...</code></td>
<td>Decrypted messages</td>
<td>Client-side</td>
</tr>
<tr>
<td>P2P DMs</td>
<td>Not available</td>
<td>Encrypted, server-free</td>
<td>iroh transport</td>
</tr>
<tr>
<td>Channel state after netsplit</td>
<td>Server authority</td>
<td>CRDT merge</td>
<td>Invisible to clients</td>
</tr>
<tr>
<td>Message tags (reactions, typing)</td>
<td>Not available</td>
<td>✓</td>
<td>IRCv3 <code>message-tags</code> CAP</td>
</tr>
</tbody></table>
<h3>The Seam: IRCv3 CAP Negotiation</h3>
<p>CAP negotiation is the right boundary. It was designed for exactly this:</p>
<pre><code>Client: CAP LS
Server: CAP * LS :sasl message-tags
Client: CAP REQ :sasl message-tags
Server: CAP * ACK :sasl message-tags
</code></pre>
<p>We currently advertise: <code>sasl message-tags</code></p>
<p>We should extend to:</p>
<pre><code>CAP * LS :sasl message-tags did-identity channel-crdt p2p-dm
</code></pre>
<p>Where:</p>
<ul>
<li><strong><code>did-identity</code></strong> — Server will include DID and AT handle in WHOIS numerics (672, etc.)</li>
<li><strong><code>channel-crdt</code></strong> — Channel state is CRDT-backed; client may see members from other servers</li>
<li><strong><code>p2p-dm</code></strong> — Server supports relaying iroh endpoint IDs for peer-to-peer DMs</li>
</ul>
<p>A legacy client that doesn&#39;t REQ these caps sees a standard IRC server. No special cases in the protocol handler. The CAP bitmask determines what extra information flows.</p>
<h3>What Legacy Clients Miss (Explicitly)</h3>
<ol>
<li><strong>Identity portability</strong> — Your nick is server-local. No DID, no proof of identity.</li>
<li><strong>E2EE</strong> — You see <code>ENC1:nonce:ciphertext</code> as the message body. You can&#39;t decrypt it. This is intentional — encrypted rooms are opt-in and participants must use a capable client.</li>
<li><strong>P2P DMs</strong> — Not available. DMs go through the server as standard PRIVMSG.</li>
<li><strong>Moderation context</strong> — You can&#39;t see that a ban is DID-based, not hostmask-based. It still works (the server enforces it), but you can&#39;t inspect why.</li>
</ol>
<h3>What Legacy Clients DO Get</h3>
<ol>
<li><strong>Full IRC</strong> — JOIN, PART, PRIVMSG, MODE, KICK, TOPIC, NAMES, WHOIS, all work.</li>
<li><strong>Guest access</strong> — Connect without SASL, get a nick, chat.</li>
<li><strong>Operator privileges</strong> — If granted by an authenticated user, work normally.</li>
<li><strong>Plaintext channels</strong> — Any channel without E2EE enabled works identically.</li>
</ol>
<hr>
<h2>2. Moderation in a DID-First World</h2>
<p>This is the harder problem. IRC&#39;s moderation model assumes server authority:</p>
<ul>
<li><strong>Chanops</strong> are granted by other chanops or the server</li>
<li><strong>Server opers</strong> have god mode</li>
<li><strong>Bans</strong> are hostmask patterns, tied to connection metadata</li>
<li><strong>K-lines</strong> are server-level bans</li>
</ul>
<p>When identity is portable (DIDs) and servers are peers (CRDT mesh), every one of these assumptions breaks.</p>
<h3>2.1 What Breaks</h3>
<p><strong>Nick-based ops lose meaning across servers.</strong> If Alice is a chanop on Server A and Bob joins from Server B, who granted Alice&#39;s authority? Server A did. But Server B has never seen Alice.</p>
<p><strong>Hostmask bans become meaningless with portable identity.</strong> A ban on <code>alice!*@*</code> doesn&#39;t work when Alice reconnects via iroh with a different transport address. DID-based bans work (<code>did:plc:abc123</code>), but they require the ban to be a semantic statement about <em>identity</em>, not <em>connection metadata</em>.</p>
<p><strong>Server authority fragments.</strong> In classic IRC, the server you&#39;re connected to is the authority. In a mesh, there&#39;s no single authority for a channel.</p>
<h3>2.2 What We&#39;re Building</h3>
<h4>DID-Based Bans (Already Implemented)</h4>
<p>We already support banning by DID:</p>
<pre><code>/ban did:plc:abc123
</code></pre>
<p>This bans the cryptographic identity, not a hostname. It works regardless of how the user connects (TCP, TLS, iroh, different IP). The ban entry is stored in <code>BanEntry</code> with both hostmask and DID matching.</p>
<h4>Moderation Log as a CRDT</h4>
<p>The feedback is exactly right: <strong>the moderation log itself must be a CRDT.</strong></p>
<p>Current state: our <code>crdt.rs</code> uses flat keys like <code>ban:{channel}:{mask} → set_by</code>. This handles add/remove cleanly via Automerge&#39;s put/delete semantics.</p>
<p>But it doesn&#39;t capture:</p>
<ul>
<li><strong>Who</strong> performed the action</li>
<li><strong>When</strong> (causal ordering)</li>
<li><strong>Why</strong> (reason)</li>
<li><strong>Conflict resolution</strong> for concurrent ban + unban</li>
</ul>
<h4>Proposed: Moderation Events in the CRDT</h4>
<pre><code>modaction:{channel}:{ulid} → {
  &quot;action&quot;: &quot;ban&quot;,
  &quot;target&quot;: &quot;did:plc:abc123&quot;,
  &quot;by&quot;: &quot;did:plc:operator&quot;,
  &quot;reason&quot;: &quot;spam&quot;,
  &quot;timestamp&quot;: 1707500000
}
</code></pre>
<p>Using ULIDs (time-sortable unique IDs) as keys means:</p>
<ul>
<li>No two moderation actions conflict (unique keys)</li>
<li>Temporal ordering is preserved</li>
<li>The full moderation history is auditable</li>
<li>Concurrent ban + unban produces <em>both</em> events in the log</li>
</ul>
<p>To determine current ban state, you <strong>fold the moderation log</strong>: replay actions in causal order, applying bans and unbans. The last action wins.</p>
<p>This is more expensive than a simple set, but it gives us:</p>
<ul>
<li><strong>Auditability</strong> — Full history of who did what and when</li>
<li><strong>Conflict resolution</strong> — Concurrent actions are both recorded; latest wins</li>
<li><strong>Portability</strong> — The moderation log travels with the channel state across servers</li>
<li><strong>Accountability</strong> — Every moderation action is attributed to a DID</li>
</ul>
<h4>Authority Model</h4>
<p>The hard question: <strong>who is allowed to moderate?</strong></p>
<p>Options, from simplest to most sophisticated:</p>
<p><strong>Option A: Channel founder model</strong> (simplest)</p>
<ul>
<li>The DID that creates a channel is the founder</li>
<li>Founders can grant/revoke operator status</li>
<li>Operator grants are themselves CRDT entries: <code>op:{channel}:{did} → granting_did</code></li>
<li>Only operators can add moderation events</li>
<li>Server validates operator status before accepting ban/kick commands</li>
</ul>
<p><strong>Option B: Threshold model</strong></p>
<ul>
<li>Moderation actions require N-of-M operator agreement</li>
<li>A ban proposed by one operator becomes effective only when K others confirm</li>
<li>The CRDT stores proposals and confirmations separately</li>
<li>More complex, but resistant to rogue operators</li>
</ul>
<p><strong>Option C: Reputation/stake model</strong> (future)</p>
<ul>
<li>Moderation weight tied to identity reputation</li>
<li>AT Protocol social graph as a trust signal</li>
<li>Out of scope for now, but the CRDT structure supports it</li>
</ul>
<p><strong>Our choice: Option A first</strong>, with the CRDT schema designed to support B later.</p>
<h3>2.3 The Merge Problem</h3>
<p>What happens when two servers in a mesh have conflicting moderation state?</p>
<p><strong>Scenario:</strong> Server A bans <code>did:plc:evil</code>. Server B unbans <code>did:plc:evil</code>. Both happen concurrently before sync.</p>
<p><strong>With our moderation log approach:</strong></p>
<ol>
<li>After sync, both events exist in the CRDT</li>
<li>Both have timestamps (and Automerge causal ordering)</li>
<li>Fold the log: the temporally-later action wins</li>
<li>If truly simultaneous: Automerge&#39;s deterministic conflict resolution picks one</li>
<li>Both servers converge to the same state</li>
</ol>
<p><strong>Scenario:</strong> Server A&#39;s operator bans a user. Server B doesn&#39;t recognize A&#39;s operator.</p>
<p><strong>Resolution:</strong></p>
<ol>
<li>Operator grants are also in the CRDT</li>
<li>If the grant hasn&#39;t synced yet, Server B will reject the ban locally</li>
<li>Once the grant syncs, Server B can re-evaluate</li>
<li>Alternatively: accept all moderation events and validate authority during fold</li>
</ol>
<p>This is why the moderation log is better than a simple ban set — you can retroactively validate authority as state converges.</p>
<h3>2.4 What&#39;s Implemented Now vs. What&#39;s Next</h3>
<p><strong>Now:</strong></p>
<ul>
<li>DID-based bans (server-local, <code>BanEntry</code> with DID matching)</li>
<li>Automerge CRDT with <code>ban:{channel}:{mask} → set_by</code></li>
<li>Channel ops granted per-session</li>
</ul>
<p><strong>Next:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Moderation event log in CRDT (ULIDs, full attribution)</li>
<li><input disabled="" type="checkbox"> Operator grants as CRDT entries (DID → DID)</li>
<li><input disabled="" type="checkbox"> Authority validation during ban fold</li>
<li><input disabled="" type="checkbox"> Channel founder registration (first DID to create channel)</li>
<li><input disabled="" type="checkbox"> CAP extension for moderation transparency (<code>mod-log</code> capability?)</li>
</ul>
<hr>
<h2>3. Why This Matters (BlueYard Thesis Alignment)</h2>
<p>This project sits at the intersection of:</p>
<ol>
<li><p><strong>Open protocol infrastructure</strong> — IRC is the original open chat protocol. We&#39;re not replacing it; we&#39;re upgrading the substrate.</p>
</li>
<li><p><strong>Crypto-native identity</strong> — DIDs from the AT Protocol give us portable, self-sovereign identity without a new identity system. Your Bluesky account IS your IRC account.</p>
</li>
<li><p><strong>P2P transport</strong> — Iroh gives us encrypted, NAT-traversing, relay-capable connectivity without centralized infrastructure.</p>
</li>
<li><p><strong>Local-first data</strong> — Automerge CRDTs mean server state is replicated, conflict-free, and doesn&#39;t require a consensus leader.</p>
</li>
</ol>
<p>The thesis: <strong>you can modernize a 37-year-old protocol without breaking it, by upgrading identity, transport, and state management independently.</strong> Each layer is separable. Each layer degrades gracefully. No single point of failure.</p>
<p>If this works for IRC, it&#39;s a template for upgrading any open protocol infrastructure.</p>
  </div>
</body>
</html>
