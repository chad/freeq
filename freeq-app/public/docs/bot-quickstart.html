<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Build Your First freeq Bot in 10 Minutes ‚Äî freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">‚Üê Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>Build Your First freeq Bot in 10 Minutes</h1>
<p>This guide walks you through building, running, and extending an IRC bot on freeq using the Rust SDK.</p>
<h2>Prerequisites</h2>
<ul>
<li>Rust (1.75+)</li>
<li>A running freeq server (or use <code>irc.freeq.at:6697</code>)</li>
</ul>
<h2>1. Create the project</h2>
<pre><code class="language-bash">cargo new mybot
cd mybot
cargo add freeq-sdk --path ../freeq-sdk  # or from crates.io
cargo add tokio --features full
cargo add clap --features derive
cargo add tracing-subscriber
cargo add anyhow
</code></pre>
<h2>2. Write the bot</h2>
<pre><code class="language-rust">// src/main.rs
use anyhow::Result;
use freeq_sdk::bot::Bot;
use freeq_sdk::client::{ClientHandle, ConnectConfig, ReconnectConfig, run_with_reconnect};
use freeq_sdk::event::Event;
use std::sync::Arc;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt::init();

    // Build the bot
    let mut bot = Bot::new(&quot;!&quot;, &quot;mybot&quot;)
        .rate_limit(5, Duration::from_secs(30));  // 5 commands per 30s per user

    bot.command(&quot;ping&quot;, &quot;Check if the bot is alive&quot;, |ctx| {
        Box::pin(async move {
            ctx.react(&quot;üèì&quot;).await?;    // react to the message
            ctx.reply_to(&quot;pong!&quot;).await // reply with mention
        })
    });

    bot.command(&quot;echo&quot;, &quot;Echo your message&quot;, |ctx| {
        Box::pin(async move {
            let text = ctx.args_str();
            if text.is_empty() {
                ctx.reply(&quot;Usage: !echo &lt;message&gt;&quot;).await
            } else {
                ctx.reply_in_thread(&amp;text).await  // reply in thread
            }
        })
    });

    // Connect with auto-reconnect
    let config = ConnectConfig {
        server_addr: &quot;irc.freeq.at:6697&quot;.into(),
        nick: &quot;mybot&quot;.into(),
        user: &quot;mybot&quot;.into(),
        realname: &quot;My First Bot&quot;.into(),
        tls: true,
        ..Default::default()
    };

    let reconnect = ReconnectConfig {
        channels: vec![&quot;#bots&quot;.into()],
        ..Default::default()
    };

    let bot = Arc::new(bot);
    run_with_reconnect(config, None, reconnect, move |handle: ClientHandle, event: Event| {
        let bot = bot.clone();
        Box::pin(async move {
            bot.handle_event(&amp;handle, &amp;event).await;
            Ok(())
        })
    }).await
}
</code></pre>
<h2>3. Run it</h2>
<pre><code class="language-bash">cargo run
</code></pre>
<p>That&#39;s it. The bot connects to <code>irc.freeq.at</code>, joins <code>#bots</code>, and responds to <code>!ping</code>, <code>!echo</code>, and <code>!help</code>. It auto-reconnects on disconnect with exponential backoff.</p>
<h2>Core Concepts</h2>
<h3>Commands</h3>
<pre><code class="language-rust">// Anyone can use this
bot.command(&quot;ping&quot;, &quot;description&quot;, handler);

// Only DID-authenticated users
bot.auth_command(&quot;secret&quot;, &quot;description&quot;, handler);

// Only admin DIDs
let bot = Bot::new(&quot;!&quot;, &quot;mybot&quot;).admin(&quot;did:plc:abc123&quot;);
bot.admin_command(&quot;kick&quot;, &quot;description&quot;, handler);
</code></pre>
<h3>CommandContext</h3>
<p>Every handler receives a <code>CommandContext</code> with:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.reply(&quot;text&quot;)</code></td>
<td>Send to channel or PM</td>
</tr>
<tr>
<td><code>ctx.reply_to(&quot;text&quot;)</code></td>
<td>Reply with <code>nick: text</code> prefix</td>
</tr>
<tr>
<td><code>ctx.reply_in_thread(&quot;text&quot;)</code></td>
<td>Reply in thread (uses +draft/reply)</td>
</tr>
<tr>
<td><code>ctx.react(&quot;üî•&quot;)</code></td>
<td>React to the triggering message</td>
</tr>
<tr>
<td><code>ctx.typing()</code> / <code>ctx.typing_done()</code></td>
<td>Send typing indicator</td>
</tr>
<tr>
<td><code>ctx.arg(0)</code></td>
<td>Get Nth argument</td>
</tr>
<tr>
<td><code>ctx.args_str()</code></td>
<td>Full argument string</td>
</tr>
<tr>
<td><code>ctx.sender</code></td>
<td>Who sent the command</td>
</tr>
<tr>
<td><code>ctx.sender_did</code></td>
<td>Their DID (if authenticated)</td>
</tr>
<tr>
<td><code>ctx.msgid()</code></td>
<td>Message ID from IRCv3 tags</td>
</tr>
<tr>
<td><code>ctx.is_channel</code></td>
<td>True if sent in a channel</td>
</tr>
</tbody></table>
<h3>ClientHandle Helpers</h3>
<p>The handle (available via <code>ctx.handle</code>) has convenience methods:</p>
<pre><code class="language-rust">// Messaging
handle.privmsg(&quot;#chan&quot;, &quot;hello&quot;).await;
handle.reply(&quot;#chan&quot;, &quot;msgid123&quot;, &quot;threaded reply&quot;).await;
handle.edit_message(&quot;#chan&quot;, &quot;msgid123&quot;, &quot;corrected text&quot;).await;
handle.delete_message(&quot;#chan&quot;, &quot;msgid123&quot;).await;

// Channels
handle.join_many(&amp;[&quot;#a&quot;, &quot;#b&quot;, &quot;#c&quot;]).await;
handle.mode(&quot;#chan&quot;, &quot;+o&quot;, Some(&quot;nick&quot;)).await;
handle.topic(&quot;#chan&quot;, &quot;New topic&quot;).await;
handle.pin(&quot;#chan&quot;, &quot;msgid123&quot;).await;

// Typing
handle.typing_start(&quot;#chan&quot;).await;
handle.typing_stop(&quot;#chan&quot;).await;

// History
handle.history_latest(&quot;#chan&quot;, 50).await;
handle.history_before(&quot;#chan&quot;, &quot;msgid&quot;, 20).await;

// Reactions
handle.react(&quot;#chan&quot;, &quot;üéâ&quot;, &quot;msgid123&quot;).await;
</code></pre>
<h3>Rate Limiting</h3>
<p>Built-in per-user rate limiting:</p>
<pre><code class="language-rust">let bot = Bot::new(&quot;!&quot;, &quot;mybot&quot;)
    .rate_limit(5, Duration::from_secs(30))  // 5 cmds / 30s
    .max_args(500);  // reject args &gt; 500 chars
</code></pre>
<p>When a user exceeds the limit, the bot replies &quot;Slow down ‚Äî too many commands.&quot; automatically.</p>
<h3>Reconnection</h3>
<p><code>run_with_reconnect</code> handles the full lifecycle:</p>
<ul>
<li>Connects to the server</li>
<li>Rejoins configured channels after each reconnect</li>
<li>Exponential backoff with jitter (2s ‚Üí 4s ‚Üí 8s ‚Üí ... ‚Üí 30s cap)</li>
<li>Calls your handler for every event (including <code>Disconnected</code>)</li>
</ul>
<pre><code class="language-rust">let reconnect = ReconnectConfig {
    channels: vec![&quot;#bots&quot;.into(), &quot;#ops&quot;.into()],
    initial_delay: Duration::from_secs(2),
    max_delay: Duration::from_secs(30),
    ..Default::default()
};
</code></pre>
<h3>Fallback Handler</h3>
<p>Catch messages that don&#39;t match any command:</p>
<pre><code class="language-rust">bot.on_message(|ctx| {
    Box::pin(async move {
        if ctx.args_raw.to_lowercase().contains(&quot;hello&quot;) {
            ctx.react(&quot;üëã&quot;).await?;
        }
        Ok(())
    })
});
</code></pre>
<h3>Permissions</h3>
<p>Three levels, checked before the handler runs:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Check</th>
</tr>
</thead>
<tbody><tr>
<td><code>Anyone</code></td>
<td>No check</td>
</tr>
<tr>
<td><code>Authenticated</code></td>
<td><code>sender_did.is_some()</code></td>
</tr>
<tr>
<td><code>Admin</code></td>
<td>DID in bot&#39;s admin list</td>
</tr>
</tbody></table>
<h2>Examples</h2>
<p>See <code>freeq-sdk/examples/</code>:</p>
<ul>
<li><strong><code>echo_bot.rs</code></strong> ‚Äî Minimal bot (10 lines of logic)</li>
<li><strong><code>framework_bot.rs</code></strong> ‚Äî Command routing + permissions</li>
<li><strong><code>moderation_bot.rs</code></strong> ‚Äî Full-featured: threads, reactions, typing, rate limiting, admin commands, auto-reconnect</li>
</ul>
<h2>What&#39;s Next</h2>
<ul>
<li><strong>Media uploads</strong>: Use <code>freeq_sdk::media</code> + PDS OAuth to upload images/audio and share via <code>handle.send_media()</code></li>
<li><strong>E2EE channels</strong>: Use <code>freeq_sdk::e2ee</code> for encrypted channel messages</li>
<li><strong>AT Protocol identity</strong>: Authenticate as a DID with <code>--handle alice.bsky.social</code> for verified bot identity</li>
<li><strong>Custom IRC</strong>: Use <code>handle.raw()</code> for any IRC command not covered by helpers</li>
</ul>
  </div>
</body>
</html>
