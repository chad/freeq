<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Freeq CRDT Federation Audit — Issues & Recommended Path Forward — freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">← Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>Freeq CRDT Federation Audit — Issues &amp; Recommended Path Forward</h1>
<p>Audience: Freeq server developers working on S2S federation + Automerge CRDT integration<br>Scope: CRDT doc (<code>freeq-server/src/crdt.rs</code>), S2S transport/protocol (<code>freeq-server/src/s2s.rs</code>, <code>server.rs</code>, <code>iroh.rs</code>), and their interaction.</p>
<hr>
<h2>Executive summary</h2>
<p>Freeq&#39;s core choice — <strong>hybrid federation</strong> (S2S event stream for &quot;chat&quot; + CRDT for convergent &quot;facts&quot;) — is a good architecture.</p>
<p>However, there are a handful of issues that can cause <strong>non-convergence, excessive re-sync traffic, ghost state, split-brain semantics, and operational pain</strong> as the cluster grows beyond &quot;two nodes in a happy path.&quot;</p>
<p>This doc lists the problems found and recommends a CRDT-expert path forward:</p>
<ul>
<li>Make peer identity consistent and cryptographic</li>
<li>Define explicit ownership / authority boundaries for &quot;who is allowed to write what&quot;</li>
<li>Make presence lease-based (or non-CRDT)</li>
<li>Make CRDT application + S2S event application idempotent and replay-safe</li>
<li>Add compaction + snapshotting and real sync observability</li>
<li>Replace blocking locks in async hot paths</li>
</ul>
<hr>
<h2>Observed architecture (so we&#39;re on the same page)</h2>
<h3>Two layers of federation</h3>
<ol>
<li><strong>S2S &quot;events&quot;</strong>: newline-delimited JSON messages over a QUIC stream (iroh) to propagate IRC-like events (<code>JOIN</code>, <code>PART</code>, <code>PRIVMSG</code>, etc.).</li>
<li><strong>CRDT doc</strong>: an Automerge document that stores cluster &quot;facts&quot; (membership-ish, topic, founder, DID ops, bans, nick ownership), replicated using Automerge sync messages embedded in S2S messages.</li>
</ol>
<h3>CRDT schema style</h3>
<ul>
<li>Uses <strong>flat keys</strong> at the Automerge root (e.g., <code>topic:{channel}</code>, <code>member:{channel}:{nick}</code>) to avoid nested-map creation conflicts.</li>
</ul>
<p>This is good, pragmatic CRDT engineering.</p>
<hr>
<h2>Critical problems and advice</h2>
<h3>1) CRDT peer identity mismatch (likely to break sync correctness/efficiency)</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Sync traffic stays high and never &quot;settles.&quot;</li>
<li>Some peers appear perpetually behind, or do repeated &quot;catch up&quot; bursts.</li>
<li>Automerge <code>generate_sync_message</code> keeps producing data even when you expect <code>None</code>.</li>
<li>In worst cases, it can stall convergence in some topologies.</li>
</ul>
<p><strong>Why this happens</strong>
Automerge sync requires that each counterparty have a stable per-peer sync state keyed consistently. If we key sync state by one identifier when sending, but a different identifier when receiving, we effectively maintain <em>two</em> sync states for &quot;the same peer,&quot; which wrecks the protocol&#39;s efficiency and can impact correctness in practice.</p>
<p><strong>Freeq-specific risk pattern</strong></p>
<ul>
<li>Outbound sync state is keyed by the <em>iroh endpoint id</em> (cryptographic transport identity).</li>
<li>Inbound sync state is keyed by the <em>server_name string</em> (logical identity) taken from message origin.</li>
</ul>
<p>That&#39;s a mismatch. One peer = two IDs.</p>
<p><strong>Advice / fix</strong></p>
<ul>
<li><strong>Key Automerge sync state by the transport&#39;s cryptographic identity</strong> (iroh endpoint id) everywhere.</li>
<li>Include both in the message if you want human debugging:<ul>
<li><code>origin_peer_id</code> (iroh endpoint id) — use for sync state keys</li>
<li><code>origin_server_name</code> — use for display/logging</li>
</ul>
</li>
<li>Ensure that whatever you pass into <code>crdt_receive_sync(peer_id, ...)</code> matches what you use for <code>generate_sync_message(peer_id)</code>.</li>
</ul>
<p><strong>Implementation note</strong></p>
<ul>
<li>Treat <code>server_name</code> as untrusted display metadata unless you cryptographically bind it to the endpoint identity.</li>
</ul>
<hr>
<h3>2) Presence encoded as CRDT keys will create &quot;ghost users&quot; without leases</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Users appear in NAMES even after disconnects/crashes.</li>
<li>Remote membership never fully drains if a server dies without emitting PART/QUIT events.</li>
<li>Cluster doc grows unbounded with stale <code>member:*</code> keys.</li>
</ul>
<p><strong>Why</strong>
Presence is inherently ephemeral and failure-prone. CRDTs are excellent at converging durable facts, but presence requires <strong>leases</strong> (time-bounded assertions) or a separate authority model.</p>
<p>In &quot;pure CRDT presence,&quot; removal requires a removal event. Crashes remove the ability to emit that event.</p>
<p><strong>Advice / fixes (pick one)</strong>
A) <strong>Lease-based presence (recommended if you want CRDT presence)</strong></p>
<ul>
<li>Store presence records with:<ul>
<li><code>member:{chan}:{nick}:{origin_server} -&gt; {last_seen_ts}</code></li>
</ul>
</li>
<li>Each server periodically refreshes its own presence for its users.</li>
<li>Each server locally considers a member &quot;present&quot; only if <code>now - last_seen_ts &lt; TTL</code>.</li>
<li>No global deletion needed; stale records just age out.</li>
<li>Optional: periodic compaction that deletes obviously ancient leases.</li>
</ul>
<p>B) <strong>Make presence NOT CRDT</strong></p>
<ul>
<li>Keep presence as S2S event-driven only, owned by origin server, with periodic &quot;full state resync&quot; on reconnect.</li>
<li>CRDT stores only durable authorization facts (founder, ops DIDs, bans, nick ownership, channel config).</li>
</ul>
<p><strong>Expert guidance</strong>
Presence is the most common &quot;CRDT footgun.&quot; If you keep it in CRDT, do leases.</p>
<hr>
<h3>3) &quot;Founder is first-write-wins&quot; is not guaranteed under concurrency</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Two servers create the same channel concurrently and disagree on founder initially.</li>
<li>Eventually they converge, but founder might be arbitrary (deterministic but not semantically &quot;first&quot;).</li>
</ul>
<p><strong>Why</strong>
Automerge resolves concurrent writes deterministically, not by wall-clock first. &quot;Only set if absent&quot; is not safe under concurrency without causal ordering.</p>
<p><strong>Advice</strong>
Decide what founder <em>means</em>:</p>
<ul>
<li>If founder is a convenience pointer: deterministic winner is fine.</li>
<li>If founder is a security boundary: you need a stronger invariant.</li>
</ul>
<p><strong>Options</strong>
A) <strong>Make founder explicitly owned</strong></p>
<ul>
<li>Founder is set by the server that hosts the first authenticated join with a DID, and the message is signed/authorized by that DID (or by a server policy).</li>
<li>Or restrict channel creation to one &quot;authority server&quot; per channel prefix / shard.</li>
</ul>
<p>B) <strong>Use a CRDT-friendly &quot;min&quot; register</strong></p>
<ul>
<li>Store a tuple <code>(timestamp, actor_id, did)</code> and take the minimal tuple.  </li>
<li>Requires trustworthy timestamp policy (or monotonic server ticks) and accepted actor ordering.</li>
</ul>
<p>C) <strong>Two-phase channel creation</strong></p>
<ul>
<li>S2S handshake: &quot;channel create request&quot; -&gt; &quot;channel create accepted&quot; to serialize creation.</li>
<li>More complex, but strong semantics.</li>
</ul>
<hr>
<h3>4) Authority boundaries are underspecified (who is allowed to write CRDT keys)</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>A malicious or buggy peer can:<ul>
<li>claim ops DIDs for itself</li>
<li>set bans for arbitrary channels</li>
<li>set nick_owner values</li>
</ul>
</li>
<li>Or simply diverge policy and poison the shared doc.</li>
</ul>
<p><strong>Why</strong>
CRDTs replicate <em>whatever operations a peer performs</em>. Without an authority model, replication is &quot;trust everyone.&quot;</p>
<p><strong>Advice</strong>
Define <strong>write authority</strong> per key-space:</p>
<ul>
<li><code>topic:{channel}</code>: only channel ops (DID-based) or a designated &quot;channel authority server&quot;</li>
<li><code>ban:{channel}:*</code>: only ops</li>
<li><code>did_op:{channel}:*</code>: only founder or existing ops (bootstrap issue)</li>
<li><code>nick_owner:{nick}</code>: only the DID proving ownership (via SASL) or a global registry rule</li>
</ul>
<p><strong>Enforcement strategies</strong></p>
<ol>
<li><strong>Soft enforcement</strong> (fastest to ship)</li>
</ol>
<ul>
<li>Accept all CRDT ops, but treat values as <em>claims</em>.</li>
<li>Before using a claim, check:<ul>
<li>does the origin server have authority?</li>
<li>is the DID authenticated on that server?</li>
<li>does it pass policy?</li>
</ul>
</li>
<li>This requires storing provenance (who wrote it), which Automerge can provide via actor IDs, but you&#39;ll want explicit metadata too.</li>
</ul>
<ol start="2">
<li><strong>Hard enforcement</strong> (real security)</li>
</ol>
<ul>
<li>Sign CRDT operations or signed &quot;state claims&quot; (ed25519) and only apply verified changes.</li>
<li>Or run a constrained CRDT API: peers don&#39;t send raw CRDT ops; they send signed high-level intents that each server applies locally to its doc.</li>
</ul>
<p><strong>Practical recommendation</strong>
Start with soft enforcement + provenance + logging; migrate to hard enforcement if the cluster becomes adversarial.</p>
<hr>
<h3>5) Hybrid S2S events + CRDT facts risks duplication / ordering confusion without idempotency</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Duplicate joins/parts, duplicated messages, weird topic flips, inconsistent NAMES.</li>
<li>Hard-to-reproduce race conditions during reconnect/resync.</li>
</ul>
<p><strong>Why</strong>
You have:</p>
<ul>
<li>an event stream that can be re-sent after reconnect</li>
<li>a CRDT doc that converges separately</li>
<li>and potentially a SyncRequest/SyncResponse bootstrap path</li>
</ul>
<p>Unless every applied event is idempotent and/or deduped, reconnect behavior creates &quot;double-apply&quot; bugs.</p>
<p><strong>Advice</strong></p>
<ul>
<li>Give every S2S event a stable <code>event_id</code>:<ul>
<li><code>(origin_peer_id, monotonic_counter)</code> or <code>(origin_peer_id, uuidv7)</code></li>
</ul>
</li>
<li>Maintain a bounded LRU per origin of seen event ids.</li>
<li>Make &quot;apply event&quot; idempotent:<ul>
<li><code>JOIN</code>: set membership; don&#39;t assume not present</li>
<li><code>PART</code>: remove membership; don&#39;t assume present</li>
<li><code>TOPIC</code>: if you keep topic in CRDT, don&#39;t also set topic via event (pick one source of truth)</li>
</ul>
</li>
</ul>
<p><strong>Key decision</strong>
Pick <em>one</em> source of truth for each domain:</p>
<ul>
<li>Topic: CRDT or S2S, not both</li>
<li>Membership: leases (CRDT) or S2S + resync, not both</li>
</ul>
<hr>
<h3>6) CRDT doc growth and compaction: Automerge can bloat without maintenance</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Memory usage grows over time.</li>
<li>Sync payload sizes gradually increase.</li>
<li>Latency spikes when saving/loading doc.</li>
</ul>
<p><strong>Why</strong>
CRDTs accumulate history. Automerge needs periodic compaction/snapshotting strategies in long-lived deployments.</p>
<p><strong>Advice</strong></p>
<ul>
<li>Implement periodic:<ul>
<li><code>save()</code> to durable storage (already present)</li>
<li>compaction strategy: snapshot the current state and discard old history where safe</li>
</ul>
</li>
<li>Consider:<ul>
<li>One doc per channel (or per shard) instead of one global doc</li>
<li>Or segment &quot;presence&quot; into a separate doc you can discard aggressively</li>
</ul>
</li>
</ul>
<p><strong>Operational instrumentation</strong></p>
<ul>
<li>Track doc size, number of changes, sync message sizes, time-to-generate-sync.</li>
</ul>
<hr>
<h3>7) Blocking <code>std::sync::Mutex</code> in async paths can stall the runtime</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Latency spikes under load.</li>
<li>Occasional &quot;stutter&quot; where all clients feel it.</li>
<li>Deadlock risk if lock ordering gets complex.</li>
</ul>
<p><strong>Why</strong>
<code>std::sync::Mutex</code> blocks the executor thread. In async Rust servers, prefer <code>tokio::sync::{Mutex,RwLock}</code> or isolate shared mutable state into a single task with message passing.</p>
<p><strong>Advice</strong></p>
<ul>
<li>Move CRDT mutation into a dedicated &quot;state task&quot;:<ul>
<li>inbound messages -&gt; channel -&gt; state task</li>
<li>state task mutates doc + produces outbound updates</li>
</ul>
</li>
<li>Or switch to <code>tokio::sync::RwLock</code> where reads dominate.</li>
</ul>
<hr>
<h3>8) Transport identity vs logical identity: need explicit binding</h3>
<p><strong>Symptom class</strong></p>
<ul>
<li>Confusing logs: server_name spoofing</li>
<li>Peer lists showing inconsistent identities</li>
<li>Potential policy bypass if any logic trusts server_name</li>
</ul>
<p><strong>Advice</strong></p>
<ul>
<li>Treat iroh endpoint id as the root identity.</li>
<li>Bind <code>server_name</code> to endpoint id via:<ul>
<li>config allowlist mapping</li>
<li>or a signed &quot;hello&quot; handshake at connection establishment</li>
</ul>
</li>
</ul>
<hr>
<h2>Recommended path forward (practical, staged)</h2>
<h3>Phase 0: Observability + invariants (do this first)</h3>
<ul>
<li>Add metrics:<ul>
<li>sync msg size distribution</li>
<li>time between sync settles</li>
<li>doc size / change count</li>
</ul>
</li>
<li>Add debug endpoint/command:<ul>
<li>print known peers + their sync &quot;in sync?&quot; state</li>
<li>list channels + founder + ops set + topic provenance</li>
</ul>
</li>
</ul>
<h3>Phase 1: Fix correctness hazards</h3>
<ol>
<li><strong>Unify peer identity used for CRDT sync state</strong> (iroh endpoint id everywhere).</li>
<li>Decide source of truth:<ul>
<li>topic: CRDT only, or S2S only</li>
<li>presence: lease CRDT, or S2S-only</li>
</ul>
</li>
<li>Add event id + dedupe for S2S messages.</li>
<li>Add authoritative write boundaries (at least soft enforcement).</li>
</ol>
<h3>Phase 2: Make it robust under failure</h3>
<ul>
<li>Presence leases (if CRDT presence)</li>
<li>Reconnect protocol:<ul>
<li>exchange CRDT sync until stable</li>
<li>then replay missed events (or skip if CRDT covers it)</li>
</ul>
</li>
<li>Pruning / cleanup strategy for stale keys.</li>
</ul>
<h3>Phase 3: Scale + security hardening</h3>
<ul>
<li>Doc sharding (per-channel or per-shard)</li>
<li>Compaction/snapshot policy</li>
<li>Optional signed claims / high-level intent replication</li>
</ul>
<hr>
<h2>Concrete design recommendations (a &quot;good default&quot;)</h2>
<h3>A. Use CRDT for durable facts, not for chat or transient state</h3>
<p>CRDT doc should contain:</p>
<ul>
<li>channel config + durable authority:<ul>
<li><code>founder:{chan} -&gt; did</code></li>
<li><code>op:{chan}:{did} -&gt; 1</code></li>
<li><code>ban:{chan}:{target} -&gt; {policy}</code></li>
<li><code>topic:{chan} -&gt; {text, set_by, ts}</code> (if you want)</li>
</ul>
</li>
<li>nick ownership:<ul>
<li><code>nick_owner:{nick} -&gt; did</code> (but enforce by proof)</li>
</ul>
</li>
</ul>
<p>Avoid:</p>
<ul>
<li>message history in CRDT (unless you want full replicated logs)</li>
<li>ephemeral presence without leases</li>
</ul>
<h3>B. Presence either:</h3>
<ul>
<li>S2S events only + periodic resync, OR</li>
<li>CRDT leases with TTL interpretation, not &quot;set/unset&quot; keys</li>
</ul>
<h3>C. Make federation idempotent by construction</h3>
<ul>
<li>Every S2S event has an <code>event_id</code></li>
<li>Every handler is &quot;set-based,&quot; not &quot;assume and mutate&quot;</li>
<li>Reconnect can replay safely</li>
</ul>
<hr>
<h2>Testing plan (CRDT + federation reliability)</h2>
<h3>1) Deterministic simulation tests (most valuable)</h3>
<p>Build a &quot;cluster simulator&quot; test harness:</p>
<ul>
<li>N servers</li>
<li>random partitions / heals</li>
<li>message drops / reorder / duplicates</li>
<li>concurrent operations (topic, ops, bans, nick claims)</li>
</ul>
<p>Assertions:</p>
<ul>
<li>convergence: all servers reach the same derived &quot;facts&quot; eventually</li>
<li>no unbounded growth in presence</li>
<li>dedupe correctness: applying same event twice yields no change</li>
</ul>
<h3>2) Soak tests</h3>
<ul>
<li>3–5 nodes, churn clients, kill -9 nodes randomly, run for hours</li>
<li>watch sync traffic + doc size</li>
</ul>
<h3>3) Adversarial peer tests</h3>
<ul>
<li>peer sends invalid server_name</li>
<li>peer tries to set ops/bans without authority</li>
<li>verify local policy rejects/ignores</li>
</ul>
<hr>
<h2>&quot;If we do nothing&quot; risk assessment</h2>
<p>If you ship federation as-is and use it beyond toy scale:</p>
<ul>
<li>CRDT sync may become inefficient or inconsistent due to peer-id mismatch</li>
<li>ghost presence will accumulate</li>
<li>reconnect partitions will create duplicate-apply bugs</li>
<li>authority poisoning is possible if peers aren&#39;t fully trusted</li>
<li>runtime latency spikes may emerge from blocking locks</li>
</ul>
<hr>
<h2>Suggested next PRs (small, high-impact)</h2>
<ol>
<li><strong>Normalize CRDT peer IDs</strong></li>
</ol>
<ul>
<li>Add <code>origin_peer_id</code> to CRDT sync messages</li>
<li>Key sync state by that everywhere</li>
</ul>
<ol start="2">
<li><strong>Add S2S event ids + dedupe</strong></li>
</ol>
<ul>
<li>minimal LRU per peer</li>
</ul>
<ol start="3">
<li><strong>Choose source of truth for topic + presence</strong></li>
</ol>
<ul>
<li>write it down and enforce it in code</li>
</ul>
<ol start="4">
<li><strong>Presence leases OR presence out of CRDT</strong></li>
</ol>
<ul>
<li>implement one; delete the other pathway</li>
</ul>
<ol start="5">
<li><strong>Add metrics</strong></li>
</ol>
<ul>
<li>doc size, sync sizes, sync settle rate</li>
</ul>
<hr>
<h2>Notes on &quot;flat key&quot; schema</h2>
<p>This was a smart choice. Keep it.
But:</p>
<ul>
<li>add namespacing discipline (<code>topic|ban|op|founder|presence|nick_owner</code>)</li>
<li>avoid storing large values in single keys (topic ok; history not)</li>
</ul>
<hr>
<h2>Closing</h2>
<p>Freeq&#39;s federation can be a strong, modern system if we:</p>
<ul>
<li>treat CRDT as the convergent store of durable facts,</li>
<li>make ephemeral state lease-based or non-CRDT,</li>
<li>ensure peer identity consistency,</li>
<li>define write authority boundaries,</li>
<li>and make S2S idempotent.</li>
</ul>
<p>That&#39;s the difference between &quot;cool demo&quot; and &quot;it holds up under partitions.&quot;</p>
  </div>
</body>
</html>
