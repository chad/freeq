<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>freeq Encryption & Security ‚Äî freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">‚Üê Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>freeq Encryption &amp; Security</h1>
<blockquote>
<p><strong>Goal</strong>: Everything encrypted by default. This document maps every data path in freeq, what&#39;s protected today, and what&#39;s not yet.</p>
</blockquote>
<h2>Overview</h2>
<p>freeq has encryption at multiple layers ‚Äî transport, authentication, federation, and (planned) message-level. Some paths are fully encrypted today. Others have gaps. We&#39;re transparent about both.</p>
<hr>
<h2>The Scorecard</h2>
<table>
<thead>
<tr>
<th>Data Path</th>
<th>Encrypted?</th>
<th>Mechanism</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Web client ‚Üî Server</strong></td>
<td>‚úÖ Yes</td>
<td>TLS 1.3 (HTTPS/WSS)</td>
<td>nginx terminates TLS with Let&#39;s Encrypt cert</td>
</tr>
<tr>
<td><strong>iOS app ‚Üî Server</strong></td>
<td>‚úÖ Yes</td>
<td>TLS 1.3 (WSS)</td>
<td>App Transport Security enforces HTTPS</td>
</tr>
<tr>
<td><strong>IRC client ‚Üî Server (TLS)</strong></td>
<td>‚úÖ Yes</td>
<td>TLS 1.3 (port 6697)</td>
<td>rustls with Let&#39;s Encrypt cert</td>
</tr>
<tr>
<td><strong>IRC client ‚Üî Server (plain)</strong></td>
<td>‚ùå No</td>
<td>Plaintext TCP (port 6667)</td>
<td>Legacy IRC compat; should use TLS port</td>
</tr>
<tr>
<td><strong>Server ‚Üî Auth Broker</strong></td>
<td>‚úÖ Yes</td>
<td>HTTPS + HMAC-SHA256</td>
<td>All broker API calls over TLS; request bodies signed with shared secret</td>
</tr>
<tr>
<td><strong>Auth Broker ‚Üî Bluesky PDS</strong></td>
<td>‚úÖ Yes</td>
<td>HTTPS + OAuth 2.0 + DPoP</td>
<td>Token-bound proof-of-possession; PDS credentials never leave the broker</td>
</tr>
<tr>
<td><strong>Server ‚Üî Server (S2S)</strong></td>
<td>‚úÖ Yes</td>
<td>QUIC (iroh)</td>
<td>iroh uses Noise protocol over QUIC; peer identity = Ed25519 public key</td>
</tr>
<tr>
<td><strong>Server ‚Üî SQLite (at rest)</strong></td>
<td>‚úÖ Yes</td>
<td>AES-256-GCM per message</td>
<td>Key derived from server signing key via HMAC; backward-compatible with legacy plaintext</td>
</tr>
<tr>
<td><strong>Server ‚Üî Policy DB (at rest)</strong></td>
<td>‚ùå No</td>
<td>Plaintext on disk</td>
<td>Channel policies, credentials</td>
</tr>
<tr>
<td><strong>Message content (in transit)</strong></td>
<td>üü° Transport only</td>
<td>TLS protects the pipe, not the payload</td>
<td>Server sees plaintext; E2E DMs available</td>
</tr>
<tr>
<td><strong>Message content (at rest)</strong></td>
<td>‚úÖ Yes</td>
<td>AES-256-GCM (EAR1: prefix)</td>
<td>New messages encrypted; old messages readable as-is</td>
</tr>
<tr>
<td><strong>Message signatures</strong></td>
<td>‚úÖ Yes (client + server)</td>
<td>ed25519 via <code>+freeq.at/sig</code> IRCv3 tag</td>
<td>Client-side signing with session keys; server fallback for legacy clients</td>
</tr>
<tr>
<td><strong>DM content</strong></td>
<td>üü° E2E available</td>
<td>Double Ratchet (X3DH + AES-256-GCM)</td>
<td>E2EE auto-enabled between DID-authenticated users; server sees ciphertext</td>
</tr>
<tr>
<td><strong>File uploads (in transit)</strong></td>
<td>‚úÖ Yes</td>
<td>HTTPS to server ‚Üí HTTPS to PDS</td>
<td>Uploaded via TLS to server, proxied via TLS to AT Protocol PDS</td>
</tr>
<tr>
<td><strong>File uploads (at rest)</strong></td>
<td>üü° PDS-dependent</td>
<td>Stored on user&#39;s PDS (Bluesky infra)</td>
<td>Not under freeq&#39;s control; PDS may or may not encrypt at rest</td>
</tr>
<tr>
<td><strong>Authentication challenge</strong></td>
<td>‚úÖ Yes</td>
<td>Cryptographic challenge-response</td>
<td>Server issues nonce ‚Üí client signs with DID key ‚Üí server verifies</td>
</tr>
<tr>
<td><strong>OAuth tokens</strong></td>
<td>‚úÖ Yes</td>
<td>In-memory only, TLS transport</td>
<td>Never written to disk; lost on server restart</td>
</tr>
<tr>
<td><strong>Broker tokens</strong></td>
<td>‚úÖ Yes</td>
<td>HMAC-signed, TLS transport</td>
<td>Short-lived; broker refreshes PDS tokens on demand</td>
</tr>
<tr>
<td><strong>Verifier signing key</strong></td>
<td>üü° Partial</td>
<td>Persisted to disk as plaintext file</td>
<td><code>verifier-signing-key.secret</code>; filesystem permissions are the only protection</td>
</tr>
<tr>
<td><strong>Hostname/IP</strong></td>
<td>‚úÖ Cloaked</td>
<td><code>freeq/plc/xxxxxxxx</code> format</td>
<td>Real IP never exposed to other users</td>
</tr>
</tbody></table>
<hr>
<h2>What&#39;s Encrypted Today</h2>
<h3>Transport Layer (Client ‚Üî Server)</h3>
<p>Every production connection is TLS-encrypted:</p>
<ul>
<li><strong>Web/iOS</strong>: Connect via <code>wss://irc.freeq.at</code> ‚Äî nginx terminates TLS 1.3 with a Let&#39;s Encrypt certificate, proxies to the local HTTP server.</li>
<li><strong>IRC over TLS</strong>: Port 6697 uses rustls with the same Let&#39;s Encrypt cert. Direct TLS termination, no proxy.</li>
<li><strong>Plain IRC</strong>: Port 6667 exists for legacy compatibility. <strong>This is the one unencrypted client path.</strong> We recommend TLS for all connections.</li>
</ul>
<h3>Authentication (SASL ATPROTO-CHALLENGE)</h3>
<p>The authentication flow is cryptographically sound:</p>
<ol>
<li>Server generates a random challenge (session-bound nonce + timestamp)</li>
<li>Client signs the challenge with their DID&#39;s private key (secp256k1 or ed25519)</li>
<li>Server resolves the DID document, extracts the public key, verifies the signature</li>
<li><strong>Private keys never leave the client device</strong></li>
<li>Challenge expires after 60 seconds and is invalidated after use (no replay)</li>
</ol>
<h3>Auth Broker Communication</h3>
<p>The auth broker (handles OAuth with Bluesky PDS) is secured at multiple levels:</p>
<ul>
<li>All communication over HTTPS</li>
<li>Every request body is HMAC-SHA256 signed with a shared secret</li>
<li>Server verifies the signature before processing any broker message</li>
<li>OAuth tokens use DPoP (Demonstrating Proof of Possession) ‚Äî tokens are bound to the client&#39;s key pair</li>
<li>PDS credentials are held in-memory on the broker only; never sent to the IRC server</li>
</ul>
<h3>Server-to-Server Federation</h3>
<p>S2S federation uses <a href="https://iroh.computer/">iroh</a>, which provides:</p>
<ul>
<li><strong>QUIC transport</strong>: All data encrypted in transit</li>
<li><strong>Noise protocol</strong>: Mutual authentication via Ed25519 keypairs</li>
<li><strong>Peer identity</strong>: Each server has a stable Ed25519 identity derived from a persistent key</li>
<li><strong>NAT traversal</strong>: Works across NATs without exposing plain ports</li>
</ul>
<h3>Hostname Cloaking</h3>
<p>User IPs are never visible to other users:</p>
<ul>
<li>DID-authenticated users: <code>freeq/plc/xxxxxxxx</code> (8-char hash of DID)</li>
<li>Guest users: <code>freeq/guest</code></li>
<li>The server knows the real IP (for rate limiting), but it&#39;s never broadcast</li>
</ul>
<hr>
<h2>What&#39;s NOT Encrypted (Yet)</h2>
<h3>1. Message Content ‚Äî Server Sees Everything</h3>
<p><strong>This is the biggest gap.</strong></p>
<p>freeq currently operates like Slack, Discord, and every other centralized chat: the server can read all messages. Transport encryption (TLS) protects messages from network observers, but the server itself has full access.</p>
<p>This matters because:</p>
<ul>
<li>A compromised server leaks all history</li>
<li>The server operator can read DMs</li>
<li>Law enforcement requests to the server operator expose content</li>
</ul>
<h3>2. Data at Rest (Partial)</h3>
<p>Message content is now encrypted at rest using AES-256-GCM. Each message is individually encrypted before SQLite storage, with a key derived from the server&#39;s signing key via HMAC-SHA256. Legacy messages (stored before encryption was enabled) remain readable as plaintext.</p>
<p><strong>What&#39;s encrypted</strong>: Message text in the <code>messages</code> table (PRIVMSG, NOTICE, edits).</p>
<p><strong>What&#39;s NOT encrypted</strong>: Channel metadata, policies, identities, sender nicks, timestamps. A compromised disk still reveals who talked to whom and when ‚Äî but not what they said.</p>
<h3>3. Message Signatures (Partial)</h3>
<p>Messages are now signed with server-attested ed25519 signatures. Every PRIVMSG/NOTICE from a DID-authenticated user carries a <code>+freeq.at/sig</code> tag containing a base64url-encoded signature over <code>{sender_did}\0{target}\0{text}\0{timestamp}</code>. The server&#39;s signing public key is published at <code>/api/v1/signing-key</code>.</p>
<p><strong>What this provides:</strong></p>
<ul>
<li>Federated servers can verify message provenance</li>
<li>Signed messages are distinguishable from unsigned (guest) messages</li>
<li>Signatures survive S2S relay</li>
</ul>
<p><strong>What this does NOT provide (yet):</strong></p>
<ul>
<li>The server could still theoretically forge signatures (it holds the signing key)</li>
<li>True end-to-end non-repudiation requires client-side signing (Phase 2)</li>
</ul>
<h3>4. File Uploads</h3>
<p>Uploaded media lives on the user&#39;s AT Protocol PDS (typically Bluesky infrastructure). freeq doesn&#39;t control PDS encryption policies. The server proxies uploads over TLS, but the PDS storage is opaque to us.</p>
<h3>5. Verifier Signing Key</h3>
<p>The credential verifier&#39;s signing key is stored as a plaintext file on disk. It should be in a hardware security module (HSM) or at minimum an encrypted keystore.</p>
<hr>
<h2>Roadmap</h2>
<h3>Phase 1 + 1.5: Message Signing (P0) ‚úÖ SHIPPED</h3>
<p><strong>Status</strong>: Implemented (client-side + server fallback)</p>
<p>Every message from a DID-authenticated user is cryptographically signed:</p>
<pre><code>@+freeq.at/sig=&lt;base64url-signature&gt; PRIVMSG #channel :Hello world
</code></pre>
<ul>
<li><strong>Signed data</strong>: <code>{target}\0{text}\0{timestamp}</code> (canonical form)</li>
<li><strong>Key types</strong>: secp256k1 (required), ed25519 (recommended)</li>
<li><strong>Verification</strong>: Anyone can verify against the sender&#39;s DID document</li>
<li><strong>Scope</strong>: PRIVMSG, NOTICE, TOPIC, KICK</li>
<li><strong>Guest messages</strong>: Unsigned ‚Äî clearly distinguishable from verified messages</li>
</ul>
<p><strong>Client-side signing (Phase 1.5)</strong> is now shipped. Clients (SDK, web, iOS) generate a per-session ed25519 keypair, register the public key with the server via <code>MSGSIG</code>, and sign every outgoing PRIVMSG. The server verifies the client&#39;s signature and relays it unchanged ‚Äî the server <strong>cannot forge</strong> client-signed messages.</p>
<p>For clients that don&#39;t support signing (legacy IRC clients), the server still signs as a fallback, providing message provenance through federation.</p>
<p>Client session signing keys are published at <code>GET /api/v1/signing-keys/{did}</code> so any party can verify signatures independently.</p>
<h3>Phase 2: End-to-End Encryption for DMs ‚úÖ SHIPPED</h3>
<p><strong>Status</strong>: Implemented (web client)</p>
<p>DMs between DID-authenticated users are end-to-end encrypted:</p>
<ul>
<li>X25519 key exchange (X3DH ‚Äî Extended Triple Diffie-Hellman)</li>
<li>Double Ratchet with AES-256-GCM message encryption</li>
<li>Pre-key bundles uploaded to server for async key exchange</li>
<li>Sessions persisted in IndexedDB (survive page reload)</li>
<li>Canonical DH ordering ensures both sides derive the same shared secret</li>
<li>Server stores ciphertext only (<code>ENC3:</code> prefix) ‚Äî can&#39;t read DM content</li>
<li>Auto-session establishment on first message or first received encrypted message</li>
</ul>
<p><strong>Remaining</strong>: Multi-device key sync.</p>
<p>Recent improvements:</p>
<ul>
<li>Pre-key bundles are now persisted to SQLite (survive server restart)</li>
<li>SPK signatures are verified using Ed25519 signing keys (prevents MITM)</li>
<li>Safety number verification UX (Signal-style 60-digit fingerprint)</li>
<li>DH ratchet step every 10 messages (forward secrecy on key compromise)</li>
<li>iOS E2EE via Rust FFI (FreeqE2ee manager: generate/restore keys, establish sessions, encrypt/decrypt, safety numbers, session import/export for Keychain persistence)</li>
</ul>
<h3>Phase 3: E2E Encrypted Channels</h3>
<p><strong>Status</strong>: Future research</p>
<p>Group E2E encryption is hard. Approaches under consideration:</p>
<ul>
<li><strong>MLS (Messaging Layer Security)</strong>: IETF standard for group E2E, but complex</li>
<li><strong>Sender keys</strong>: Simpler, used by Signal for groups, weaker forward secrecy</li>
<li><strong>Per-message encryption to each member</strong>: Doesn&#39;t scale past ~50 members</li>
</ul>
<p>Trade-offs:</p>
<ul>
<li>E2E channels can&#39;t have server-side search or history for new members</li>
<li>Moderation becomes harder (server can&#39;t inspect content)</li>
<li>This may be opt-in per channel rather than default</li>
</ul>
<h3>Phase 4: Encrypted Storage at Rest ‚úÖ SHIPPED (message content)</h3>
<p>Message text is encrypted with AES-256-GCM before SQLite storage. Key stored in a <strong>separate</strong> <code>db-encryption-key.secret</code> file, independent of the message signing key. On first run, the key is derived from the signing key for backward compatibility with existing encrypted data, then persisted separately. This ensures a signing key compromise does not also compromise encrypted data.</p>
<p><strong>Remaining</strong>: Encrypt channel metadata, policies, and identity tables. Full-database encryption via SQLCipher.</p>
<h3>Phase 5: HSM for Server Keys</h3>
<ul>
<li>Verifier signing key in hardware</li>
<li>TLS private key in hardware</li>
<li>Iroh identity key in hardware</li>
</ul>
<hr>
<h2>Comparison</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th align="center">freeq (today)</th>
<th align="center">Slack</th>
<th align="center">Discord</th>
<th align="center">Signal</th>
<th align="center">Matrix</th>
</tr>
</thead>
<tbody><tr>
<td>Transport encryption</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ</td>
</tr>
<tr>
<td>E2E DMs</td>
<td align="center">‚úÖ</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ*</td>
</tr>
<tr>
<td>E2E group chat</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ*</td>
</tr>
<tr>
<td>Message signatures</td>
<td align="center">‚úÖ*</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚úÖ</td>
<td align="center">‚ùå</td>
</tr>
<tr>
<td>Decentralized identity</td>
<td align="center">‚úÖ</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚úÖ</td>
</tr>
<tr>
<td>Server can read messages</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">Yes*</td>
</tr>
<tr>
<td>Open protocol</td>
<td align="center">‚úÖ</td>
<td align="center">‚ùå</td>
<td align="center">‚ùå</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ</td>
</tr>
<tr>
<td>Encrypted at rest</td>
<td align="center">‚úÖ*</td>
<td align="center">Unknown</td>
<td align="center">Unknown</td>
<td align="center">‚úÖ</td>
<td align="center">Varies</td>
</tr>
<tr>
<td>IP cloaking</td>
<td align="center">‚úÖ</td>
<td align="center">N/A</td>
<td align="center">‚úÖ</td>
<td align="center">‚úÖ</td>
<td align="center">Varies</td>
</tr>
</tbody></table>
<p>*Matrix E2E is opt-in and <a href="https://matrix.org/blog/2024/matrix-2-0/">has had verification UX issues</a>.<br>*Client-side session key signing shipped; server fallback for legacy clients.</p>
<hr>
<h2>Threat Model</h2>
<h3>What freeq protects against today</h3>
<ul>
<li><strong>Network eavesdropping</strong>: All production connections use TLS</li>
<li><strong>Identity spoofing</strong>: DID-based authentication with cryptographic challenge-response</li>
<li><strong>Credential theft</strong>: Private keys never leave the client; OAuth uses DPoP token binding</li>
<li><strong>IP exposure</strong>: Hostname cloaking hides real addresses</li>
<li><strong>Nick squatting</strong>: DID-to-nick binding prevents impersonation</li>
<li><strong>Replay attacks</strong>: SASL challenges are nonce-based, time-limited, single-use</li>
<li><strong>Broker tampering</strong>: HMAC signatures on all broker API calls</li>
</ul>
<h3>What freeq does NOT protect against today</h3>
<ul>
<li><strong>Compromised server operator</strong>: Can read all messages and metadata</li>
<li><strong>Compromised server host</strong>: Plaintext database on disk</li>
<li><strong>Metadata analysis</strong>: Server knows who talks to whom, when, and how often</li>
<li><strong>Compromised PDS</strong>: Uploaded media controlled by PDS operator</li>
<li><strong>Message forgery by server</strong>: Closed for modern clients (client-side signing). Legacy clients still use server-attested signatures.</li>
<li><strong>Pre-key bundle substitution</strong>: Mitigated ‚Äî SPK signatures are verified with Ed25519 signing keys. Safety number verification available for out-of-band confirmation.</li>
</ul>
<h3>Federation security (S2S)</h3>
<p>Federated peers are now authorization-checked:</p>
<ul>
<li><strong>Mode changes</strong> (+o, +v, +t, +i, +n, +m, +k): Receiving server verifies the setter is an op before executing</li>
<li><strong>Kicks</strong>: Receiving server verifies the kicker is an op</li>
<li><strong>Topic</strong> (+t channels): Only ops can set topics ‚Äî no &quot;trust the peer&quot; fallback</li>
<li><strong>Joins</strong>: Receiving server enforces bans and +i (invite-only) on incoming S2S joins</li>
<li><strong>Rate limiting</strong>: 100 events/sec per peer; excess dropped with warning log</li>
</ul>
<p>A rogue federated peer <strong>cannot</strong>:</p>
<ul>
<li>Grant themselves op status</li>
<li>Kick users from channels they don&#39;t control</li>
<li>Change topics on locked channels</li>
<li>Bypass bans by joining from a different server</li>
<li>Flood the server with events</li>
</ul>
<hr>
<h2>Philosophy</h2>
<p>We believe encryption should be <strong>default, not optional</strong>. The current gaps exist because we shipped transport security first (the layer that matters most immediately) and are building message-layer security in the open.</p>
<p>We&#39;re not going to claim E2E when we don&#39;t have it. We&#39;re not going to hide the fact that the server can read your messages today. Instead, we&#39;re publishing this document, shipping the fixes in order of impact, and inviting scrutiny.</p>
<p>The AT Protocol gives us a unique advantage: every user already has a cryptographic identity (DID) with signing keys. We don&#39;t need to invent a key distribution system ‚Äî it already exists. Message signing and E2E encryption can build on infrastructure that&#39;s already deployed to millions of users.</p>
<p><strong>If you find a security issue</strong>, please report it to <a href="mailto:security@freeq.at">security@freeq.at</a> or open a GitHub issue.</p>
  </div>
</body>
</html>
