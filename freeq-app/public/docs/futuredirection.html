<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Future Direction — freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">← Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>Future Direction</h1>
<p>This document is organized into three sections: <strong>immediate gaps</strong> (things that should be fixed before wider use), <strong>pragmatic next steps</strong> (concrete features that extend the existing architecture), and <strong>long-term ideas</strong> (bigger bets that may reshape the project).</p>
<p>See also: <code>docs/s2s-audit.md</code> for the full S2S sync architectural audit.</p>
<hr>
<h2>1. Immediate Gaps &amp; Fixes</h2>
<h3><del>1.1 IRC Spec Compliance</del> ✅ DONE</h3>
<p>All P0/P1 IRC commands implemented: LIST, WHO, AWAY, MOTD, +n, +m, SASL abort.</p>
<h3>1.2 IRCv3 Extensions Still Missing</h3>
<ul>
<li><p><strong><code>account-notify</code> / <code>account-tag</code></strong> — When a user authenticates via SASL, notify other users. Natural for Freeq since DID authentication is a core feature.</p>
</li>
<li><p><strong><code>away-notify</code></strong> — Broadcast AWAY state changes to shared channels. The server already tracks AWAY status; this just adds the broadcast.</p>
</li>
<li><p><strong><code>extended-join</code></strong> — Include account name (DID) in JOIN messages. Trivial with existing infrastructure.</p>
</li>
<li><p><strong><code>CHATHISTORY</code> command</strong> — Allow clients to request history on demand, not just on join. The persistence layer already supports pagination. This is the missing piece to make history truly useful.</p>
</li>
</ul>
<h3>1.3 Remaining AT Protocol Issues</h3>
<ul>
<li><p><strong>DPoP nonce staleness</strong> — The DPoP nonce is captured once and reused. PDS servers rotate nonces. The media upload code has retry logic, but the SASL verification path (<code>verify_pds_oauth</code>) doesn&#39;t. If the nonce rotates, server-side verification fails.</p>
</li>
<li><p><strong>PDS session verification is trust-the-PDS</strong> — The <code>pds-session</code> method trusts the PDS to honestly report the DID. A compromised PDS could claim any DID. Crypto verification should be preferred.</p>
</li>
<li><p><strong>Only tested against Bluesky PDS</strong> — AT Protocol has other implementations (self-hosted PDS, alternative networks). DID resolution, OAuth endpoints, and PDS APIs may behave differently.</p>
</li>
</ul>
<h3>1.4 Concurrency &amp; Safety</h3>
<ul>
<li><strong>Lock ordering</strong> — <code>SharedState</code> uses many <code>Mutex&lt;T&gt;</code> fields, and handlers frequently lock multiple mutexes. No documented lock ordering creates deadlock risk. Some handlers acquire <code>channels</code> then <code>connections</code>, others <code>nick_to_session</code> then <code>channels</code>. A consistent ordering (or restructuring to reduce lock scope) would prevent subtle deadlocks under load.</li>
</ul>
<hr>
<h2>2. Pragmatic Next Steps</h2>
<h3>2.1 S2S Hardening (see docs/s2s-audit.md)</h3>
<p><strong>P2 — S2S authentication:</strong>
Currently any server can join the mesh by knowing an endpoint ID. Add mutual authentication for S2S links. The iroh endpoint provides cryptographic identity (public key); verify against an allowlist.</p>
<p><strong>P2 — Ban state sync:</strong>
Bans are local-only despite the CRDT having ban support. Wire up S2S messages for ban add/remove, enforce bans on S2S Join.</p>
<p><strong>P2 — S2S Join enforcement:</strong>
Incoming S2S Joins don&#39;t check bans or +i. A user banned on Server 1 can still appear from Server 2.</p>
<p><strong>P3 — Wire CRDT to live S2S:</strong>
The Automerge CRDT exists and is designed for this problem. The flat-key schema (<code>founder:{channel}</code>, <code>mode:{channel}:t</code>, etc.) provides convergent merge. Currently two separate state systems (CRDT + ad-hoc JSON messages). Wiring the CRDT to live S2S would solve most split-brain issues permanently.</p>
<p><strong>P3 — Moderation event log:</strong>
Replace flat ban entries with CRDT-backed moderation log (ULID-keyed events with attribution). Enables auditability, retroactive authority validation, proper conflict resolution for concurrent ban/unban. See <code>architecture-decisions.md</code>.</p>
<h3>2.2 Database Improvements</h3>
<ul>
<li><p><strong>Time-based message retention</strong> — <code>--message-retention-days</code> in addition to count-based pruning.</p>
</li>
<li><p><strong>Full-text search</strong> — SQLite FTS5 for message search. Enables <code>/search</code> in the TUI. Small schema change; query maps to REST endpoint.</p>
</li>
</ul>
<h3>2.3 Security Hardening</h3>
<ul>
<li><p><strong>Hostname cloaking</strong> — Currently all users show <code>host</code> as their hostname. Implement IP-based cloaking or configurable virtual hosts. Expected for any public deployment.</p>
</li>
<li><p><strong>Connection limits</strong> — Per-IP connection limits. Rate limiter handles command floods but doesn&#39;t prevent thousands of idle connections.</p>
</li>
<li><p><strong>TLS client certificates</strong> — Alternative auth path for bots and services.</p>
</li>
<li><p><strong>SASL mechanism negotiation</strong> — Advertise supported mechanisms in 908 (RPL_SASLMECHS) so clients know what&#39;s available.</p>
</li>
</ul>
<h3>2.4 Operational Features</h3>
<ul>
<li><p><strong>OPER command</strong> — Server operator status with configurable credentials for remote administration (kill, kline, rehash).</p>
</li>
<li><p><strong>Server-level bans (K-line / G-line)</strong> — Ban by IP, DID, or pattern at server level. Stored in DB, enforced on connect.</p>
</li>
<li><p><strong>Metrics / monitoring</strong> — Prometheus metrics (connection count, message rate, auth success/failure, S2S link health) via <code>/metrics</code> endpoint.</p>
</li>
<li><p><strong>Structured logging</strong> — Request IDs that correlate across the SASL flow. Currently tracing is ad-hoc.</p>
</li>
<li><p><strong>Graceful shutdown</strong> — Send QUIT to all connected clients and close S2S links cleanly.</p>
</li>
</ul>
<h3>2.5 TUI Client Improvements</h3>
<ul>
<li><p><strong>Auto-reconnection</strong> — Auto-reconnect with backoff on disconnection. Rejoin channels, re-authenticate. The SDK&#39;s <code>establish_connection()</code> separation makes this architecturally feasible.</p>
</li>
<li><p><strong>P2P auto-discovery</strong> — Use iroh endpoint ID from WHOIS (672) to auto-connect for P2P DMs instead of manual endpoint ID exchange.</p>
</li>
<li><p><strong>URL opening</strong> — Keybinding to open URLs from messages in the default browser.</p>
</li>
<li><p><strong>Multi-server</strong> — Connect to multiple servers simultaneously, each in their own buffer group. The SDK already supports independent client instances.</p>
</li>
</ul>
<hr>
<h2>3. Long-Term Ideas</h2>
<h3>3.1 DID-Based Key Exchange for E2EE</h3>
<p>Replace passphrase-based E2EE with DID-based key exchange:</p>
<ol>
<li>Each authenticated user has a signing key (from their DID document)</li>
<li>Derive per-channel group keys using authenticated key exchange</li>
<li>Rotate keys when members join/leave</li>
<li>Use the CRDT to sync key rotation events</li>
</ol>
<p>This gives forward secrecy and verified encryption — you&#39;d know only the authenticated identities can read messages, not just anyone who knows a passphrase.</p>
<p><strong>Challenges:</strong> Key agreement protocol design, ratcheting, member join/leave rotation, offline members missing rotations.</p>
<h3>3.2 AT Protocol Record-Backed Channels</h3>
<p>Store channel metadata (topic, rules, membership policy) as AT Protocol records:</p>
<pre><code class="language-json">{
  &quot;$type&quot;: &quot;blue.irc.channel&quot;,
  &quot;name&quot;: &quot;#bluesky-dev&quot;,
  &quot;description&quot;: &quot;Bluesky development discussion&quot;,
  &quot;founder&quot;: &quot;did:plc:...&quot;,
  &quot;createdAt&quot;: &quot;2025-01-15T00:00:00Z&quot;
}
</code></pre>
<p>Makes channels discoverable via AT Protocol, enables metadata to follow the social graph, bridges IRC&#39;s ephemeral model with AT Protocol&#39;s record-oriented model.</p>
<h3>3.3 Moderation via AT Protocol Labels</h3>
<p>Integrate AT Protocol&#39;s labeling system:</p>
<ul>
<li>Server applies labels to messages or users</li>
<li>Labels are AT Protocol records, consumable by other services</li>
<li>Users subscribe to label services for filtering</li>
<li>Channel moderators issue labels that propagate via AT Protocol</li>
</ul>
<h3>3.4 Serverless Mode (Pure P2P) — DEFER</h3>
<p>Use iroh + CRDTs to create channels without any server. The server becomes optional infrastructure for discovery and persistence.</p>
<p><strong>Challenges:</strong> Message ordering, offline delivery, discovery, Sybil resistance.</p>
<h3>3.5 Bridge to AT Protocol Conversations</h3>
<p>Bridge IRC channels to AT Protocol DMs/conversations. Messages in either context appear in both. Identity unified via DID.</p>
<h3>3.6 Web Client</h3>
<p>As described in <code>proposal-web-infra.md</code>: separate repo. PWA using WebSocket transport, AT Protocol OAuth, IndexedDB for local history, Service Worker for push.</p>
<h3>3.7 Bot Framework</h3>
<p>The SDK&#39;s <code>(ClientHandle, Receiver&lt;Event&gt;)</code> pattern is already bot-friendly. Formalize:</p>
<ul>
<li>Bot SDK with command parsing, permission checks, persistence</li>
<li>Standard bots (seen, quote, factoid, RSS)</li>
<li>AT Protocol integration bots: cross-post to Bluesky, fetch profiles, relay notifications</li>
<li>Webhook bridge for GitHub/CI</li>
<li>LLM integration with DID-gated access control</li>
</ul>
<h3>3.8 Reputation &amp; Trust</h3>
<p>Use the AT Protocol social graph as a trust signal:</p>
<ul>
<li>Weight moderation actions by follower count or social distance</li>
<li>Auto-voice users followed by channel ops</li>
<li>Relaxed rate limits for verified/trusted identities</li>
<li>Anti-spam scoring based on account age and social connections</li>
</ul>
<h3>3.9 Custom Lexicon Ecosystem</h3>
<p>Expand beyond <code>blue.irc.media</code>:</p>
<ul>
<li><code>blue.irc.channel</code> — Channel metadata records</li>
<li><code>blue.irc.membership</code> — Channel subscription records</li>
<li><code>blue.irc.reaction</code> — Persistent reaction records</li>
<li><code>blue.irc.moderation</code> — Moderation event records</li>
<li><code>blue.irc.identity</code> — IRC identity binding records</li>
</ul>
<h3>3.10 IRCv3 Working Group Proposal</h3>
<p>The <code>ATPROTO-CHALLENGE</code> SASL mechanism could be proposed as an IRCv3 spec:</p>
<ol>
<li>Formal specification document (RFC-style)</li>
<li>Generalize from AT Protocol to any DID-based identity</li>
<li>Define mechanism name, challenge format, verification flow</li>
<li>Address backward compat, security considerations, deployment</li>
<li>Submit to IRCv3 working group</li>
</ol>
<hr>
<h2>Priority Matrix (Updated)</h2>
<p>All original P0/P1 items are <strong>done</strong>. The canonical TODO is in <code>CLAUDE.md</code>.
Key addition: <strong>message signing by default</strong> is P0 — all messages from DID-authenticated
users should be cryptographically signed (IRCv3 tag, end-to-end verifiable across S2S).</p>
<p>Here&#39;s what remains:</p>
<table>
<thead>
<tr>
<th>Priority</th>
<th>Item</th>
<th>Effort</th>
<th>Impact</th>
</tr>
</thead>
<tbody><tr>
<td><strong>P0</strong></td>
<td><strong>Message signing by default</strong></td>
<td>Large</td>
<td>Critical — trust foundation</td>
</tr>
<tr>
<td><strong>P1</strong></td>
<td><strong>S2S auth on Kick/Mode/Topic</strong></td>
<td>Medium</td>
<td>High — security</td>
</tr>
<tr>
<td><strong>P1</strong></td>
<td><strong>S2S rate limiting</strong></td>
<td>Medium</td>
<td>High — operational</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>S2S authentication</strong></td>
<td>Medium</td>
<td>High — security</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>S2S ban sync + enforcement</strong></td>
<td>Medium</td>
<td>High — moderation</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>Hostname cloaking</strong></td>
<td>Medium</td>
<td>Medium — privacy</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>account-notify / extended-join</strong></td>
<td>Small</td>
<td>Medium — client compat</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>away-notify</strong></td>
<td>Small</td>
<td>Medium — UX</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>CHATHISTORY command</strong></td>
<td>Medium</td>
<td>High — history UX</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>Connection limits</strong></td>
<td>Small</td>
<td>Medium — operational</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>TUI auto-reconnection</strong></td>
<td>Medium</td>
<td>High — reliability</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>OPER command</strong></td>
<td>Medium</td>
<td>Medium — admin</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td><strong>DPoP nonce retry for SASL</strong></td>
<td>Small</td>
<td>Medium — robustness</td>
</tr>
<tr>
<td>P3</td>
<td>Wire CRDT to live S2S</td>
<td>Large</td>
<td>High — correctness</td>
</tr>
<tr>
<td>P3</td>
<td>DID-based key exchange for E2EE</td>
<td>Large</td>
<td>High — security</td>
</tr>
<tr>
<td>P3</td>
<td>Full-text search</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr>
<td>P3</td>
<td>Bot framework</td>
<td>Medium</td>
<td>High — ecosystem</td>
</tr>
<tr>
<td>P3</td>
<td>AT Protocol record-backed channels</td>
<td>Large</td>
<td>Medium</td>
</tr>
<tr>
<td>P3</td>
<td>Reputation &amp; trust via social graph</td>
<td>Large</td>
<td>Medium</td>
</tr>
<tr>
<td>P3</td>
<td>Serverless P2P mode</td>
<td>Very Large</td>
<td>High — architectural</td>
</tr>
<tr>
<td>P3</td>
<td>IRCv3 WG proposal</td>
<td>Medium</td>
<td>High — ecosystem</td>
</tr>
<tr>
<td>P3</td>
<td>Web client</td>
<td>Large</td>
<td>High — adoption</td>
</tr>
</tbody></table>
  </div>
</body>
</html>
