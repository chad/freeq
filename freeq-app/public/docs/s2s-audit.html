<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>S2S Sync Audit — Architectural Flaws — freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">← Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>S2S Sync Audit — Architectural Flaws</h1>
<h2>The Core Problem</h2>
<p><strong>Each server maintains independent <code>ChannelState</code> with no shared truth.</strong></p>
<p>When User A on Server 1 creates <code>#test</code>, Server 1&#39;s <code>ChannelState</code> has:</p>
<ul>
<li><code>members: {A}</code>, <code>ops: {A}</code>, <code>founder_did: None</code> (guest)</li>
</ul>
<p>When User B on Server 2 joins <code>#test</code>, Server 2 checks its OWN <code>ChannelState</code>.
If <code>#test</code> doesn&#39;t exist on Server 2 yet, <code>is_new_channel = true</code>, so:</p>
<ul>
<li><code>members: {B}</code>, <code>ops: {B}</code>, <code>founder_did: None</code></li>
</ul>
<p><strong>Both servers independently think their user is the channel creator and op.</strong>
The S2S JOIN message arrives AFTER the local JOIN has already completed.</p>
<h2>Specific Bugs Found</h2>
<h3>Bug 1: Both Users Get Ops (The Reported Bug)</h3>
<p><strong>Flow:</strong></p>
<ol>
<li>User A on Server 1: <code>JOIN #test</code> → <code>is_new_channel=true</code> → gets ops</li>
<li>Server 1 sends S2S <code>Join { nick: &quot;A&quot;, channel: &quot;#test&quot; }</code></li>
<li>User B on Server 2: <code>JOIN #test</code></li>
<li>Server 2 checks <code>channels.contains_key(&quot;#test&quot;)</code> — <strong>may or may not exist</strong>
depending on whether the S2S Join from step 2 arrived first</li>
<li>If S2S Join arrived: channel exists, <code>is_new_channel=false</code>, B is NOT op ✓</li>
<li>If S2S Join has NOT arrived: <code>is_new_channel=true</code>, B GETS OPS ✗</li>
</ol>
<p>This is a <strong>race condition</strong>. With network latency between servers,
step 3 often wins the race against step 2.</p>
<h3>Bug 2: Mode Changes Not Enforced Cross-Server</h3>
<p>Even with the new Mode S2S message, enforcement is wrong:</p>
<ul>
<li><strong>+t is enforced at the receiving server.</strong> If Server 2 hasn&#39;t received
the Mode message yet, it allows the topic change.</li>
<li><strong>Topic change is then relayed to Server 1</strong> via S2S Topic message,
which Server 1 blindly accepts (the comment says &quot;trust the originating
server&#39;s enforcement&quot;).</li>
</ul>
<p>So: Set +t on Server 1 → Server 2 hasn&#39;t gotten the Mode msg yet →
User on Server 2 changes topic → topic change relayed to Server 1.
<strong>+t is bypassed.</strong></p>
<h3>Bug 3: NAMES Shows Inconsistent Op Status</h3>
<p><code>send_names_update</code> determines remote user op status by checking:</p>
<pre><code class="language-rust">let is_op = rm.did.as_ref().is_some_and(|d| {
    ch.founder_did.as_deref() == Some(d) || ch.did_ops.contains(d)
});
</code></pre>
<p>For <strong>guest users (no DID)</strong>, remote ops are NEVER shown. Guest users
who are op on their home server appear as regular users on the remote.</p>
<p>Session-based ops (<code>ch.ops</code>) are local only — they contain session IDs
that are meaningless on the remote server.</p>
<h3>Bug 4: Channel Created Notification Race</h3>
<p><code>handle_join</code> broadcasts <code>ChannelCreated</code> only for new channels:</p>
<pre><code class="language-rust">if is_new_channel {
    s2s_broadcast(state, S2sMessage::ChannelCreated { ... });
}
</code></pre>
<p>But if BOTH servers create the channel simultaneously (the race in Bug 1),
both send <code>ChannelCreated</code>. The <code>first-write-wins</code> merge in the handler
means whichever <code>ChannelCreated</code> arrives first on each server wins —
<strong>each server may have a DIFFERENT founder</strong>.</p>
<h3>Bug 5: Sync Response Mode Merge is One-Way Additive</h3>
<pre><code class="language-rust">if info.topic_locked { ch.topic_locked = true; }
</code></pre>
<p>Modes can only be ADDED via sync, never removed. If Server 1 sets +t
then -t, the sync response still shows <code>topic_locked: true</code> on Server 2
if the Mode S2S message for -t was lost. There&#39;s no way to correct this
other than a new sync.</p>
<p>Actually worse: the sync always sends the current state, so if Server 1
has -t, the sync shows <code>topic_locked: false</code>. But the merge code only
adopts <code>true</code>, never <code>false</code>. So the mode gets stuck on.</p>
<h3>Bug 6: No Origin Tracking on Ops</h3>
<p>The <code>ops</code> field is <code>HashSet&lt;String&gt;</code> of <strong>session IDs</strong>. These are
server-local identifiers like <code>stream-42</code>. They mean nothing on the
remote server. There&#39;s no S2S message for granting/revoking ops to
remote users.</p>
<p>A user opped on Server 1 has no op status on Server 2 unless they
have a DID that&#39;s in <code>did_ops</code>.</p>
<h3>Bug 7: S2S Privmsg Bypasses +n and +m</h3>
<p><code>process_s2s_message</code> for Privmsg:</p>
<pre><code class="language-rust">deliver_to_channel(state, &amp;target, &amp;line);
</code></pre>
<p>No check for +n (no external messages) or +m (moderated). A remote
user who is not in the channel (from the local server&#39;s perspective)
can send messages to a +n channel via S2S relay.</p>
<h3>Bug 8: S2S Topic Bypasses +t</h3>
<p>As noted in Bug 2 — the S2S Topic handler never checks <code>topic_locked</code>.
The comment says &quot;trust the originating server&quot; but the originating
server may be running old code, or may not have received the +t mode
change yet.</p>
<h3>Bug 9: Bans Not Enforced on S2S Join</h3>
<p>When a remote user joins via S2S, there&#39;s no ban check:</p>
<pre><code class="language-rust">ch.remote_members.insert(nick.clone(), RemoteMember { ... });
</code></pre>
<p>A user banned on Server 1 can still appear in the channel if they
join from Server 2.</p>
<h3>Bug 10: No S2S Ban Propagation</h3>
<p>Bans are local only. Setting <code>+b nick!*@*</code> on Server 1 has zero
effect on Server 2.</p>
<h2>Architectural Root Cause</h2>
<p>The fundamental issue is <strong>split-brain state</strong>. Each server has its
own <code>ChannelState</code> and makes independent decisions. S2S messages are
fire-and-forget with no ordering guarantees, no acknowledgment, and
no convergent merge strategy for most fields.</p>
<p>The CRDT (Automerge) exists in the codebase but is <strong>not wired to
live S2S</strong>. The <code>ClusterDoc</code> in <code>crdt.rs</code> defines a flat-key schema
but <code>process_s2s_message</code> uses ad-hoc JSON messages with in-memory
first-write-wins logic.</p>
<h2>Recommended Fixes (Priority Order)</h2>
<h3>P0: Fix the &quot;both get ops&quot; race</h3>
<p><strong>Option A (simple):</strong> On new channel creation, DON&#39;T grant ops immediately.
Wait for a configurable window (e.g., 2 seconds) for S2S sync to arrive.
If no conflicting <code>ChannelCreated</code> arrives, grant ops. This is fragile.</p>
<p><strong>Option B (correct):</strong> Only the channel <strong>as it exists on the server</strong>
determines authority. A channel is &quot;new&quot; only if it doesn&#39;t exist on ANY
server. This requires a handshake:</p>
<ol>
<li>Server sends <code>ChannelCreated</code> to S2S</li>
<li>Waits for ACK/NACK from all peers</li>
<li>Only then grants ops</li>
</ol>
<p>This is complex and adds latency.</p>
<p><strong>Option C (pragmatic, recommended):</strong></p>
<ul>
<li>Guest users on an existing-on-any-server channel do NOT get auto-op</li>
<li><code>is_new_channel</code> should check both local state AND recent S2S sync</li>
<li>When S2S Join arrives for a channel that doesn&#39;t exist locally,
create it but mark it as <code>created_remotely = true</code></li>
<li>When a local user joins a <code>created_remotely</code> channel, don&#39;t auto-op</li>
<li>Only auto-op if the channel truly didn&#39;t exist anywhere</li>
</ul>
<p><strong>Option D (simplest, good enough):</strong></p>
<ul>
<li>When we receive S2S <code>ChannelCreated</code>, if we have local ops granted
to a user with no DID (guest), and the remote founder has a DID,
revoke the local guest ops and adopt the remote founder.</li>
<li>When we create a channel locally, immediately send <code>ChannelCreated</code>
BEFORE completing the JOIN response.</li>
</ul>
<h3>P1: Fix mode enforcement</h3>
<p><strong>All S2S incoming messages must be subject to the same channel mode
checks as local messages.</strong> Specifically:</p>
<ul>
<li>S2S Topic: check +t, reject if set (or at least don&#39;t relay locally)</li>
<li>S2S Privmsg: check +n, +m</li>
<li>S2S Join: check bans, +i</li>
</ul>
<h3>P2: Fix NAMES consistency</h3>
<ul>
<li>Include op status in S2S Join messages (new field: <code>is_op: bool</code>)</li>
<li>Track which remote users are ops in <code>RemoteMember</code></li>
<li>When showing NAMES, use this info instead of only DID-based op check</li>
</ul>
<h3>P3: Fix mode sync</h3>
<ul>
<li>Replace one-way additive merge with full state replacement:
<code>ch.topic_locked = info.topic_locked</code> (not <code>if info.topic_locked</code>)</li>
<li>Mode S2S messages must include a logical timestamp or sequence number
to resolve conflicts (most recent write wins)</li>
</ul>
<h3>P3: Wire up CRDT</h3>
<p>The Automerge CRDT was designed for exactly this problem. The flat-key
schema (<code>founder:{channel}</code>, <code>mode:{channel}:t</code>, etc.) provides
convergent merge. The work to wire it to live S2S would solve most
of these issues permanently.</p>
  </div>
</body>
</html>
