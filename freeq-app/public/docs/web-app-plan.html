<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Freeq Web App â€” Design Plan â€” freeq</title>
  <style>
    :root { --bg: #0c0c0f; --fg: #e4e4e7; --fg-dim: #71717a; --accent: #818cf8; --surface: #18181b; --border: #27272a; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; line-height: 1.7; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem 4rem; }
    .nav { display: flex; align-items: center; gap: 1rem; padding: 1rem 0 2rem; border-bottom: 1px solid var(--border); margin-bottom: 2rem; }
    .nav a { color: var(--accent); text-decoration: none; font-size: 14px; }
    .nav a:hover { text-decoration: underline; }
    .nav .brand { font-weight: 700; font-size: 18px; color: var(--accent); }
    h1 { font-size: 2rem; margin: 0 0 1rem; color: var(--fg); }
    h2 { font-size: 1.4rem; margin: 2rem 0 0.75rem; color: var(--fg); border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: var(--fg); }
    p { margin: 0.75rem 0; }
    a { color: var(--accent); }
    code { background: var(--surface); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: 'SF Mono', 'Fira Code', monospace; }
    pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { text-align: left; padding: 0.5rem 0.75rem; border: 1px solid var(--border); }
    th { background: var(--surface); font-weight: 600; }
    ul, ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; color: var(--fg-dim); margin: 1rem 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    strong { color: #fff; }
    img { max-width: 100%; }
  </style>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <span class="brand">freeq</span>
      <a href="/">â† Back to app</a>
      <a href="/docs/">All docs</a>
    </nav>
    <h1>Freeq Web App â€” Design Plan</h1>
<h2>Vision</h2>
<p>A modern team communication app â€” comparable to Slack or Discord in feel â€” built on freeq&#39;s IRC+AT Protocol infrastructure. AT Protocol identity only (no guest mode in this client). Slash commands work but are never required. Every action has a GUI affordance. The protocol stays clean; the polish lives in the client.</p>
<p>This document covers: what already works, what the client must do, what protocol enhancements are needed, and a build plan.</p>
<hr>
<h2>1. What Already Exists (Protocol Inventory)</h2>
<h3>Ready to use â€” no protocol changes needed</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Protocol support</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Auth (Bluesky login)</td>
<td>SASL ATPROTO-CHALLENGE via OAuth</td>
<td>Server-side OAuth flow exists at <code>/auth/login</code> + <code>/auth/callback</code></td>
</tr>
<tr>
<td>Channels (join/part/create)</td>
<td>JOIN/PART</td>
<td>Default +nt on creation</td>
</tr>
<tr>
<td>Messages</td>
<td>PRIVMSG/NOTICE over WebSocket</td>
<td>Full IRCv3 tag support</td>
</tr>
<tr>
<td>DMs</td>
<td>PRIVMSG to nick</td>
<td>Cross-server via S2S relay</td>
</tr>
<tr>
<td>History on join</td>
<td>BATCH chathistory</td>
<td>Last 100 messages replayed</td>
</tr>
<tr>
<td>On-demand history</td>
<td>CHATHISTORY LATEST/BEFORE/AFTER</td>
<td>Paginated, server-time tagged</td>
</tr>
<tr>
<td>Topic</td>
<td>TOPIC command + 332 numeric</td>
<td>+t enforcement</td>
</tr>
<tr>
<td>Channel modes</td>
<td>+i +t +k +n +m +b +o +v</td>
<td>Full set</td>
</tr>
<tr>
<td>Kick/Ban</td>
<td>KICK, MODE +b</td>
<td>DID-based bans survive nick changes</td>
</tr>
<tr>
<td>Invite</td>
<td>INVITE</td>
<td>+i channels</td>
</tr>
<tr>
<td>Nick changes</td>
<td>NICK</td>
<td>Broadcast to shared channels</td>
</tr>
<tr>
<td>Reactions</td>
<td>TAGMSG with <code>+react</code> tag</td>
<td>Fallback ACTION for plain clients</td>
</tr>
<tr>
<td>Media attachments</td>
<td>IRCv3 tags: <code>media-url</code>, <code>content-type</code>, <code>media-alt</code></td>
<td>Uploaded to AT Protocol PDS</td>
</tr>
<tr>
<td>Link previews</td>
<td><code>text/x-link-preview</code> content type</td>
<td>Server-side OG fetching via SDK</td>
</tr>
<tr>
<td>User info</td>
<td>WHOIS (DID, handle, iroh endpoint)</td>
<td>Numerics 311/330/671/672</td>
</tr>
<tr>
<td>User list</td>
<td>NAMES (353/366) with @/+ prefixes</td>
<td></td>
</tr>
<tr>
<td>Channel list</td>
<td>LIST (322/323) with topics</td>
<td></td>
</tr>
<tr>
<td>Online check</td>
<td>ISON</td>
<td></td>
</tr>
<tr>
<td>Away status</td>
<td>AWAY (301/305/306)</td>
<td>RPL_AWAY on PM</td>
</tr>
<tr>
<td>Echo</td>
<td><code>echo-message</code> cap</td>
<td>Server echoes own messages</td>
</tr>
<tr>
<td>Account notify</td>
<td><code>account-notify</code> + <code>extended-join</code></td>
<td>DID broadcast on auth/join</td>
</tr>
<tr>
<td>REST API</td>
<td><code>/api/v1/health</code>, channels, history, users</td>
<td>Read-only, JSON</td>
</tr>
<tr>
<td>E2EE</td>
<td>ENC1 (passphrase) + ENC2 (DID-based)</td>
<td>Server-transparent</td>
</tr>
<tr>
<td>Server-time</td>
<td><code>server-time</code> cap</td>
<td>Timestamps on all messages</td>
</tr>
<tr>
<td>Multi-prefix</td>
<td><code>multi-prefix</code> cap</td>
<td>Accurate NAMES prefixes</td>
</tr>
</tbody></table>
<h3>Gaps requiring protocol enhancements</h3>
<table>
<thead>
<tr>
<th>Need</th>
<th>Current state</th>
<th>Required enhancement</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Typing indicators</strong></td>
<td>TAGMSG exists but no typing tag convention</td>
<td>Define <code>+typing</code> tag (client-only, no server storage)</td>
</tr>
<tr>
<td><strong>Read receipts / read position</strong></td>
<td>Nothing</td>
<td>Define <code>+read</code> TAGMSG with <code>msgid</code>; or server-side read marker via new command</td>
</tr>
<tr>
<td><strong>Message IDs</strong></td>
<td>Not implemented</td>
<td>Add <code>msgid</code> IRCv3 cap â€” server assigns unique ID to each message</td>
</tr>
<tr>
<td><strong>Message editing</strong></td>
<td>Not possible</td>
<td>TAGMSG with <code>+draft/edit</code> referencing original <code>msgid</code></td>
</tr>
<tr>
<td><strong>Message deletion</strong></td>
<td>Not possible</td>
<td>TAGMSG with <code>+draft/delete</code> referencing original <code>msgid</code></td>
</tr>
<tr>
<td><strong>Threads / replies</strong></td>
<td>Nothing</td>
<td><code>+reply</code> tag with parent <code>msgid</code></td>
</tr>
<tr>
<td><strong>User profiles</strong></td>
<td>WHOIS only (synchronous)</td>
<td>REST endpoint already exists. Client can also resolve AT Protocol profile (avatar, display name, bio) directly from PDS</td>
</tr>
<tr>
<td><strong>Presence (online/idle/offline)</strong></td>
<td>AWAY exists but no idle tracking</td>
<td>Expose idle time in WHO/WHOIS; consider <code>away-notify</code> cap</td>
</tr>
<tr>
<td><strong>Unread counts / badges</strong></td>
<td>Client must track locally</td>
<td>Server-side read markers (or client-side IndexedDB)</td>
</tr>
<tr>
<td><strong>Search</strong></td>
<td>No FTS</td>
<td>Add server-side <code>SEARCH</code> command or REST <code>/api/v1/search?q=</code> backed by SQLite FTS5</td>
</tr>
<tr>
<td><strong>File uploads</strong></td>
<td>SDK uploads to PDS, sends URL in tag</td>
<td>Works â€” but client needs drag-and-drop UX and progress</td>
</tr>
<tr>
<td><strong>Pinned messages</strong></td>
<td>Not implemented</td>
<td>Channel metadata: <code>+pin</code> TAGMSG or new MODE variant</td>
</tr>
<tr>
<td><strong>Bookmarks</strong></td>
<td>Not implemented</td>
<td>Client-local (IndexedDB) â€” no protocol needed</td>
</tr>
<tr>
<td><strong>User groups / mentions</strong></td>
<td>No @-group concept</td>
<td>Client-side only (expansion before send)</td>
</tr>
<tr>
<td><strong>Message signing</strong></td>
<td>P0 in TODO but not yet implemented</td>
<td><code>+freeq.at/sig</code> tag on every message from DID-auth users</td>
</tr>
</tbody></table>
<hr>
<h2>2. Protocol Enhancements (Approval Required)</h2>
<p>These additions are backward-compatible. Old clients ignore unknown tags. None change existing behavior.</p>
<h3>2.1 <code>msgid</code> â€” Message IDs (Required)</h3>
<p><strong>IRCv3 spec exists for this.</strong> Server assigns a unique ID (ULID or UUID) to each message. Carried in the <code>msgid</code> tag.</p>
<pre><code>@msgid=01HXYZ...;time=2026-02-18T15:00:00Z :alice!a@host PRIVMSG #team :hello
</code></pre>
<p><strong>Why required:</strong> Editing, deletion, replies, reactions-to-specific-message, and read markers all need to reference a specific message. Without this, none of the modern UX features work. This is the single most important protocol addition.</p>
<p><strong>Server work:</strong> ~30 lines. Generate ULID in PRIVMSG/NOTICE handler, attach as tag, store in DB.</p>
<p><strong>Backward compat:</strong> Old clients ignore the tag. CHATHISTORY replay includes msgid.</p>
<h3>2.2 <code>+typing</code> â€” Typing Indicators (Client-only)</h3>
<pre><code>@+typing=active TAGMSG #team
@+typing=done TAGMSG #team
</code></pre>
<p><strong>Why:</strong> Core modern chat UX. &quot;Alice is typing...&quot; in the input area.</p>
<p><strong>Server work:</strong> Zero. TAGMSG already relays tags. Server doesn&#39;t store these. The <code>+</code> prefix means it&#39;s a client-only tag per IRCv3 spec.</p>
<p><strong>Privacy:</strong> Only sent when the user is actively typing in a channel they&#39;ve joined. Opt-out in client settings. The server never generates these.</p>
<h3>2.3 <code>+reply</code> â€” Threaded Replies</h3>
<pre><code>@+reply=01HXYZ... :alice!a@host PRIVMSG #team :I agree with this
</code></pre>
<p><strong>Why:</strong> Lets users respond to specific messages without quoting. The client renders these as threaded or inline with a &quot;replying to...&quot; header.</p>
<p><strong>Server work:</strong> Zero â€” it&#39;s a client tag, server passes it through. History replay preserves tags. Client resolves the referenced msgid from its local message cache.</p>
<p><strong>Backward compat:</strong> Old clients see a normal message. The reply context is invisible to them (acceptable â€” same as how Discord/Slack replies appear in bridges).</p>
<h3>2.4 <code>+draft/edit</code> and <code>+draft/delete</code> â€” Message Editing and Deletion</h3>
<p>Follows the <a href="https://github.com/ircv3/ircv3-specifications/pull/524">IRCv3 draft</a> pattern:</p>
<pre><code>@+draft/edit=01HXYZ... :alice!a@host PRIVMSG #team :hello (fixed typo)
@+draft/delete=01HXYZ... TAGMSG #team
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Only the original author can edit/delete</li>
<li>Server enforces authorship (match DID or session)</li>
<li>Server stores the edit as a new message with <code>replaces</code> field</li>
<li>Clients that don&#39;t understand edits see a new message (acceptable degradation)</li>
<li>Deletes are soft â€” server marks message as deleted, clients hide it</li>
</ul>
<p><strong>Server work:</strong> Medium. Need authorship check on incoming edit/delete, DB field for <code>replaces</code>/<code>deleted_at</code>, CHATHISTORY must return edits correctly. ~100 lines.</p>
<p><strong>Approval needed:</strong> This is the most invasive change. Requires server-side enforcement. But the alternative (no editing) is a dealbreaker for a Slack replacement.</p>
<h3>2.5 <code>+read</code> â€” Read Markers (Optional, can defer)</h3>
<pre><code>@+read=01HXYZ... TAGMSG #team
</code></pre>
<p>Client sends this to indicate they&#39;ve read up to msgid <code>01HXYZ...</code>. Server can optionally store per-DID read position. Other clients for the same DID can sync unread state.</p>
<p><strong>Server work:</strong> Small if stored. Zero if client-only (IndexedDB).</p>
<p><strong>Recommendation:</strong> Start with client-local tracking (IndexedDB). Add server-side later when multi-device sync matters.</p>
<h3>2.6 <code>away-notify</code> â€” Presence Updates</h3>
<p><strong>IRCv3 spec exists.</strong> Server broadcasts AWAY changes to shared channels.</p>
<pre><code>:alice!a@host AWAY :In a meeting
:alice!a@host AWAY
</code></pre>
<p><strong>Server work:</strong> Small. The server already tracks AWAY state. Just needs to broadcast on change to channel members who negotiated the cap. ~20 lines.</p>
<h3>2.7 Search (Can defer to Phase 2)</h3>
<p>Either:</p>
<ul>
<li>REST: <code>GET /api/v1/search?q=term&amp;channel=#team&amp;limit=50</code></li>
<li>IRC: <code>SEARCH #team :search terms</code> â†’ batch of results</li>
</ul>
<p><strong>Server work:</strong> Wire up SQLite FTS5. Medium effort but not blocking for launch.</p>
<h3>2.8 Message Signing (<code>+freeq.at/sig</code>)</h3>
<p>Already P0 in TODO. Every message from a DID-authenticated user carries a cryptographic signature. The web app should:</p>
<ul>
<li>Display a &quot;verified&quot; indicator on signed messages</li>
<li>Warn on unsigned messages in authenticated channels</li>
<li>Allow clicking the indicator to see the signing DID</li>
</ul>
<hr>
<h2>3. Client Architecture</h2>
<h3>3.1 Technology</h3>
<table>
<thead>
<tr>
<th>Choice</th>
<th>Rationale</th>
</tr>
</thead>
<tbody><tr>
<td><strong>React + TypeScript</strong></td>
<td>Largest talent pool, best component ecosystem, fast iteration</td>
</tr>
<tr>
<td><strong>Vite</strong></td>
<td>Fast builds, good DX</td>
</tr>
<tr>
<td><strong>Tailwind CSS</strong></td>
<td>Utility-first, consistent with modern design teams</td>
</tr>
<tr>
<td><strong>Zustand</strong></td>
<td>Minimal state management, no boilerplate</td>
</tr>
<tr>
<td><strong>IndexedDB (Dexie)</strong></td>
<td>Local message cache, offline search, read markers</td>
</tr>
<tr>
<td><strong>Separate repo</strong></td>
<td><code>freeq-app/</code> or <code>github.com/chad/freeq-app</code>. Clean separation from infrastructure</td>
</tr>
</tbody></table>
<h3>3.2 Connection Layer</h3>
<p>The client speaks IRC over WebSocket, same as the existing <code>freeq-web/index.html</code>. But structured properly:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    React UI                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Zustand Store (state)                â”‚
â”‚  channels, messages, users, presence, unreads     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           IRC Protocol Adapter                    â”‚
â”‚  parse(), serialize(), cap negotiation, SASL      â”‚
â”‚  Translates IRC events â†’ store actions            â”‚
â”‚  Translates UI actions â†’ IRC commands             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         WebSocket Transport                       â”‚
â”‚  Auto-reconnect, message queue, health ping       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>The IRC Protocol Adapter is the key abstraction. The React UI never sees IRC protocol. It sees:</p>
<pre><code class="language-typescript">// What the store exposes
interface Channel {
  name: string;
  topic: string;
  members: Member[];
  modes: Set&lt;string&gt;;
  unreadCount: number;
  mentionCount: number;
  messages: Message[];
}

interface Message {
  id: string;          // msgid
  from: Member;
  text: string;
  timestamp: Date;
  replyTo?: string;    // parent msgid
  editOf?: string;     // original msgid
  deleted: boolean;
  reactions: Map&lt;string, Set&lt;string&gt;&gt;;  // emoji â†’ set of nicks
  media?: MediaAttachment;
  signature?: string;  // verified DID sig
  signed: boolean;
}

interface Member {
  nick: string;
  did?: string;
  handle?: string;
  displayName?: string;
  avatar?: string;     // from AT Protocol profile
  isOp: boolean;
  isVoiced: boolean;
  away?: string;
  typing: boolean;
}

// What the UI calls
interface Actions {
  sendMessage(channel: string, text: string, replyTo?: string): void;
  editMessage(channel: string, msgId: string, newText: string): void;
  deleteMessage(channel: string, msgId: string): void;
  react(channel: string, msgId: string, emoji: string): void;
  setTopic(channel: string, topic: string): void;
  joinChannel(channel: string): void;
  leaveChannel(channel: string): void;
  inviteUser(channel: string, nick: string): void;
  kickUser(channel: string, nick: string, reason?: string): void;
  setMode(channel: string, mode: string, arg?: string): void;
  uploadFile(channel: string, file: File): Promise&lt;void&gt;;
  startDM(nick: string): void;
  setAway(reason?: string): void;
}
</code></pre>
<p>The adapter layer translates bidirectionally. <code>sendMessage(&quot;team&quot;, &quot;hello&quot;)</code> becomes <code>PRIVMSG #team :hello</code>. An incoming <code>@msgid=abc;time=... :alice PRIVMSG #team :hello</code> becomes a <code>Message</code> object in the store.</p>
<h3>3.3 AT Protocol Profile Resolution</h3>
<p>When a user is encountered (JOIN, NAMES, WHOIS), the client:</p>
<ol>
<li>Gets DID from <code>extended-join</code> or <code>account-notify</code> or WHOIS 330</li>
<li>Resolves DID document (cached, 1hr TTL)</li>
<li>Fetches AT Protocol profile: <code>app.bsky.actor.getProfile</code> (public API, no auth needed)</li>
<li>Extracts: display name, avatar URL, bio</li>
<li>Caches in IndexedDB</li>
</ol>
<p>This gives every authenticated user a rich profile card â€” avatar, display name, bio â€” without any protocol changes. The data comes from the AT Protocol social layer.</p>
<p>Guests (which this client doesn&#39;t support, but may appear via S2S from other servers) show a generic avatar and their nick.</p>
<hr>
<h2>4. UX Design</h2>
<h3>4.1 Layout</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [freeq logo]  Server: irc.freeq.at  [ğŸŸ¢ connected]     â”‚
â”‚  Signed in as chadfowler.com (did:plc:...)   [@] [âš™ï¸]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        â”‚  #team                    âš™ï¸ ğŸ“Œ  â”‚               â”‚
â”‚ DIRECT â”‚  Topic: Sprint planning         â”‚  MEMBERS (12) â”‚
â”‚ â”€â”€â”€â”€â”€â”€ â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚               â”‚
â”‚ @alice â”‚  Alice Chen Â· 9:41 AM           â”‚  ğŸ‘‘ chad      â”‚
â”‚ @bob   â”‚  Has anyone reviewed the PR?    â”‚  â­ alice     â”‚
â”‚        â”‚          â†©ï¸ ğŸ‘2 â¤ï¸1              â”‚    bob        â”‚
â”‚ CHANS  â”‚                                 â”‚    carol      â”‚
â”‚ â”€â”€â”€â”€â”€â”€ â”‚  Bob Smith Â· 9:42 AM            â”‚               â”‚
â”‚ #team  â”‚  â†ª replying to Alice            â”‚  â”€â”€ Away â”€â”€   â”‚
â”‚ #eng   â”‚  Looking at it now              â”‚    dave (mtg) â”‚
â”‚ #randomâ”‚                                 â”‚               â”‚
â”‚        â”‚  Â·Â·Â· Carol is typing            â”‚               â”‚
â”‚        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚
â”‚        â”‚ [ğŸ“] Type a message...    [ğŸ˜€] [â†µ]â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>4.2 Sidebar</h3>
<p><strong>Direct Messages</strong> section at top:</p>
<ul>
<li>Shows recent DM conversations</li>
<li>Avatar + display name (from AT Protocol profile)</li>
<li>Unread badge</li>
<li>Online/away/offline indicator dot</li>
</ul>
<p><strong>Channels</strong> section below:</p>
<ul>
<li>Channel name with unread badge</li>
<li>Bold + red badge for mentions</li>
<li>Muted channels in dimmer text</li>
<li>&quot;Browse channels&quot; button (â†’ LIST command)</li>
<li>&quot;Create channel&quot; button (â†’ JOIN with new name)</li>
</ul>
<p><strong>Collapsible sections</strong> â€” user can collapse DMs or channels.</p>
<h3>4.3 Message Display</h3>
<p>Each message shows:</p>
<ul>
<li><strong>Avatar</strong> (from AT Protocol profile, or generated from DID)</li>
<li><strong>Display name</strong> (from AT Protocol, falls back to nick)</li>
<li><strong>Handle</strong> in lighter text (e.g. <code>@chadfowler.com</code>)</li>
<li><strong>Timestamp</strong> (relative: &quot;9:41 AM&quot;, hover for absolute)</li>
<li><strong>Verified badge</strong> (ğŸ”’ if message is signed, hover shows signing DID)</li>
<li><strong>Message text</strong> with:<ul>
<li>Markdown-lite rendering (bold, italic, code, code blocks)</li>
<li>Link previews (from <code>text/x-link-preview</code> tag or client-side OG fetch)</li>
<li>Image/video/audio embeds (from <code>media-url</code> tag)</li>
<li>@mentions highlighted</li>
<li>Channel links clickable (#channel â†’ switch to it)</li>
</ul>
</li>
<li><strong>Reaction bar</strong> below message (emoji counts, click to add/remove)</li>
<li><strong>Reply indicator</strong> (&quot;â†ª replying to Alice: Has anyone...&quot;) with click to scroll to original</li>
<li><strong>Edited indicator</strong> (&quot;(edited)&quot; with hover to see original)</li>
</ul>
<p><strong>Hover actions</strong> on each message (right side):</p>
<ul>
<li>ğŸ˜€ React</li>
<li>ğŸ’¬ Reply</li>
<li>âœï¸ Edit (own messages only)</li>
<li>ğŸ—‘ï¸ Delete (own messages only)</li>
<li>ğŸ“Œ Pin (ops only)</li>
<li>â‹¯ More (copy link, copy text)</li>
</ul>
<h3>4.4 Compose Box</h3>
<ul>
<li>Rich text area (not <code>&lt;input&gt;</code>)</li>
<li>Paste images â†’ auto-upload to PDS â†’ send with media tags</li>
<li>Drag and drop files â†’ same upload flow</li>
<li><code>@</code> triggers member autocomplete popup</li>
<li><code>#</code> triggers channel autocomplete popup</li>
<li><code>:</code> triggers emoji picker</li>
<li>Shift+Enter for newline (rendered with proper line breaks)</li>
<li>Up arrow on empty input â†’ edit last message</li>
<li>Reply banner above input when replying (with cancel button)</li>
<li>Typing indicator sent automatically (debounced, 3s interval)</li>
</ul>
<h3>4.5 Member List (Right Sidebar)</h3>
<ul>
<li>Grouped by role: Operators (ğŸ‘‘), Voiced (â­), Members</li>
<li>Each member shows: avatar, display name, away status</li>
<li>Click â†’ profile popover (DID, handle, bio, DM button, WHOIS info)</li>
<li>Collapsible away section</li>
<li>Online/away indicators (green dot / yellow dot)</li>
</ul>
<h3>4.6 Channel Settings (âš™ï¸ button)</h3>
<p>Modal or slide-out panel:</p>
<ul>
<li><strong>Topic</strong> â€” editable by ops (or anyone if -t)</li>
<li><strong>Modes</strong> â€” toggle switches for +i, +t, +n, +m, +k<ul>
<li>Each has a plain-language label: &quot;Invite only&quot;, &quot;Topic lock&quot;, etc.</li>
</ul>
</li>
<li><strong>Members</strong> â€” list with op/voice/kick/ban actions</li>
<li><strong>Bans</strong> â€” list current bans with unban button</li>
<li><strong>Notifications</strong> â€” mute channel, mention-only, all messages</li>
</ul>
<h3>4.7 Login Flow</h3>
<ol>
<li>User lands on app (e.g. <code>app.freeq.at</code>)</li>
<li>Single input: &quot;Enter your Bluesky handle&quot; (e.g. <code>chadfowler.com</code>)</li>
<li>Click &quot;Sign in with Bluesky&quot; â†’ OAuth redirect</li>
<li>Return â†’ auto-connect to WebSocket â†’ SASL auth â†’ join default channels</li>
<li>No server URL input, no nick input, no manual configuration<ul>
<li>Server URL from app config (or domain detection)</li>
<li>Nick derived from AT handle (e.g. <code>chadfowler</code> from <code>chadfowler.com</code>)</li>
<li>Default channels from server MOTD or app config</li>
</ul>
</li>
</ol>
<h3>4.8 Notifications</h3>
<ul>
<li>Browser Notification API for mentions and DMs (with permission prompt)</li>
<li>Title bar badge: <code>(3) freeq</code> for unread count</li>
<li>Sound (optional, off by default)</li>
<li>Per-channel notification settings (all / mentions / none)</li>
<li>Service Worker for push notifications when tab is backgrounded (Phase 2)</li>
</ul>
<h3>4.9 Keyboard Shortcuts</h3>
<table>
<thead>
<tr>
<th>Shortcut</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td>Cmd+K</td>
<td>Quick switcher (channels + DMs)</td>
</tr>
<tr>
<td>Cmd+Shift+A</td>
<td>Jump to unread</td>
</tr>
<tr>
<td>Alt+â†‘/â†“</td>
<td>Switch channels</td>
</tr>
<tr>
<td>Cmd+/</td>
<td>Show all shortcuts</td>
</tr>
<tr>
<td>Esc</td>
<td>Close modal / cancel reply</td>
</tr>
<tr>
<td>Up (empty input)</td>
<td>Edit last message</td>
</tr>
</tbody></table>
<hr>
<h2>5. What The Client Handles (No Protocol Change)</h2>
<p>Several &quot;modern&quot; features are purely client-side:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Markdown rendering</strong></td>
<td>Client parses <code>*bold*</code>, <code>_italic_</code>, <code>`code`</code>, <code> </code>blocks<code> </code>. Sent as plain text â€” old clients see the raw markdown. This is how every Slack/Discord bridge works</td>
</tr>
<tr>
<td><strong>Message grouping</strong></td>
<td>Messages from same user within 2min shown without repeated avatar/name</td>
</tr>
<tr>
<td><strong>Unread tracking</strong></td>
<td>IndexedDB stores last-read msgid per channel. Computed locally</td>
</tr>
<tr>
<td><strong>Bookmarks</strong></td>
<td>IndexedDB. Channel-level mute/pin is local preference</td>
</tr>
<tr>
<td><strong>AT Protocol profiles</strong></td>
<td>Direct PDS API calls from browser. No server involvement</td>
</tr>
<tr>
<td><strong>Emoji picker</strong></td>
<td>Client-side component with Unicode emoji</td>
</tr>
<tr>
<td><strong>File previews</strong></td>
<td>Detect <code>media-url</code> tag, render appropriate embed</td>
</tr>
<tr>
<td><strong>@mention autocomplete</strong></td>
<td>Client has NAMES data, autocomplete locally</td>
</tr>
<tr>
<td><strong>Link previews</strong></td>
<td>If server provides <code>text/x-link-preview</code> tags, render them. Otherwise client-side OG fetch (with CORS limitations)</td>
</tr>
<tr>
<td><strong>Sound notifications</strong></td>
<td>Client-side audio</td>
</tr>
<tr>
<td><strong>Theme (light/dark)</strong></td>
<td>CSS variables, local preference</td>
</tr>
<tr>
<td><strong>Compact/comfortable density</strong></td>
<td>CSS toggle</td>
</tr>
</tbody></table>
<hr>
<h2>6. Build Plan</h2>
<h3>Phase 0: Protocol Prerequisites (Server-side, ~1 week)</h3>
<p>Must be done before the web app can launch with modern UX:</p>
<ol>
<li><strong><code>msgid</code> support</strong> â€” Generate ULID for every PRIVMSG/NOTICE, attach as IRCv3 tag, store in DB, include in CHATHISTORY replay</li>
<li><strong>Message signing</strong> â€” (Already P0 in TODO) <code>+freeq.at/sig</code> tag</li>
<li><strong><code>away-notify</code> cap</strong> â€” Broadcast AWAY changes to channel members</li>
</ol>
<p>Nice to have for Phase 0 but can slip:
4. Edit/delete support (authorship check, DB schema, CHATHISTORY integration)</p>
<h3>Phase 1: Foundation (~2 weeks)</h3>
<ul>
<li>Project scaffolding (Vite + React + TypeScript + Tailwind)</li>
<li>IRC-over-WebSocket connection layer with auto-reconnect</li>
<li>IRCv3 parser/serializer (TypeScript, from scratch â€” ~200 lines)</li>
<li>CAP negotiation + SASL ATPROTO-CHALLENGE (OAuth flow)</li>
<li>Zustand store with channel/message/member state</li>
<li>Basic layout: sidebar, message list, compose box, member list</li>
<li>Message rendering: text, timestamps, avatars (from AT Protocol)</li>
<li>Join/part/create channel</li>
<li>Send/receive messages</li>
<li>CHATHISTORY loading (scroll-up pagination)</li>
</ul>
<h3>Phase 2: Rich Features (~2 weeks)</h3>
<ul>
<li>Reactions (TAGMSG <code>+react</code>, aggregate display, click to toggle)</li>
<li>Replies (TAGMSG <code>+reply</code>, inline rendering, scroll-to-parent)</li>
<li>Typing indicators (TAGMSG <code>+typing</code>)</li>
<li>File upload (drag-and-drop, paste, AT Protocol PDS upload, progress)</li>
<li>Media embeds (images, video, audio from tags)</li>
<li>Link previews</li>
<li>Markdown-lite rendering</li>
<li>Emoji picker</li>
<li>@mention and #channel autocomplete</li>
<li>Message editing (if server support ready)</li>
<li>Message deletion (if server support ready)</li>
</ul>
<h3>Phase 3: Polish (~1 week)</h3>
<ul>
<li>Unread tracking (IndexedDB)</li>
<li>Notification system (browser notifications, title badge, sounds)</li>
<li>Channel settings panel (modes, bans, members)</li>
<li>User profile popovers</li>
<li>Quick switcher (Cmd+K)</li>
<li>Keyboard shortcuts</li>
<li>Mobile responsive layout</li>
<li>Light/dark theme</li>
<li>Loading states, error handling, empty states</li>
<li>Offline indicator + queued messages</li>
</ul>
<h3>Phase 4: Production (~1 week)</h3>
<ul>
<li>PWA manifest + service worker (offline shell, push notifications)</li>
<li>Deploy to <code>app.freeq.at</code> (via Miren or static hosting)</li>
<li>Automated E2E tests (Playwright)</li>
<li>Performance: virtualized message list (react-window), lazy image loading</li>
<li>Accessibility: ARIA labels, keyboard navigation, screen reader testing</li>
</ul>
<hr>
<h2>7. Summary of Server Changes Needed</h2>
<table>
<thead>
<tr>
<th>Change</th>
<th>Effort</th>
<th>Phase</th>
<th>Blocks</th>
</tr>
</thead>
<tbody><tr>
<td><code>msgid</code> on all messages</td>
<td>Small (30 lines)</td>
<td>0</td>
<td>Editing, deletion, replies, reactions-to-msg, read markers</td>
</tr>
<tr>
<td>Message signing (<code>+freeq.at/sig</code>)</td>
<td>Medium (already planned)</td>
<td>0</td>
<td>Verified badge display</td>
</tr>
<tr>
<td><code>away-notify</code> cap</td>
<td>Small (20 lines)</td>
<td>0</td>
<td>Presence indicators</td>
</tr>
<tr>
<td><code>+typing</code> relay</td>
<td>Zero (TAGMSG works)</td>
<td>â€”</td>
<td>Nothing â€” client-only tag</td>
</tr>
<tr>
<td><code>+reply</code> relay</td>
<td>Zero (TAGMSG works)</td>
<td>â€”</td>
<td>Nothing â€” client-only tag</td>
</tr>
<tr>
<td><code>+react</code> to specific msgid</td>
<td>Zero (already works)</td>
<td>â€”</td>
<td>Already sends <code>+react</code> tag</td>
</tr>
<tr>
<td>Edit support (authorship + DB)</td>
<td>Medium (100 lines)</td>
<td>0-1</td>
<td>Message editing UX</td>
</tr>
<tr>
<td>Delete support (soft delete)</td>
<td>Medium (50 lines)</td>
<td>0-1</td>
<td>Message deletion UX</td>
</tr>
<tr>
<td>Search (FTS5)</td>
<td>Medium</td>
<td>2+</td>
<td>Search feature</td>
</tr>
</tbody></table>
<p><strong>Total server work for Phase 0: ~3 days.</strong> The <code>msgid</code> and <code>away-notify</code> changes are tiny. Edit/delete is the only medium-effort item and can slip to Phase 1.</p>
<hr>
<h2>8. What We&#39;re NOT Building</h2>
<ul>
<li><strong>Voice/video calls</strong> â€” Out of scope. Use existing tools.</li>
<li><strong>Custom emoji / sticker packs</strong> â€” Unicode emoji only.</li>
<li><strong>Bots marketplace</strong> â€” The bot framework exists in the SDK but the web app doesn&#39;t need a bot UI.</li>
<li><strong>Admin dashboard</strong> â€” Server admin is CLI. The web app is a user tool.</li>
<li><strong>Multi-server</strong> â€” This client connects to one freeq server. Multi-network is a power-user TUI feature.</li>
<li><strong>Offline message composition</strong> â€” If disconnected, show &quot;reconnecting&quot; and queue. Don&#39;t pretend to be offline-first.</li>
<li><strong>Custom themes</strong> â€” Light and dark. Not a theme engine.</li>
</ul>
<hr>
<h2>9. Open Questions</h2>
<ol>
<li><p><strong>Separate repo or monorepo?</strong> Recommendation: separate repo (<code>freeq-app</code>). The web app has a completely different build toolchain (Node/npm vs Rust/cargo). Monorepo adds complexity with no benefit.</p>
</li>
<li><p><strong>React vs Solid vs Svelte?</strong> React has the largest talent pool and component ecosystem. For a team tool that needs to ship fast and be maintained, React + TypeScript is the pragmatic choice.</p>
</li>
<li><p><strong>Should DMs show AT Protocol display names or IRC nicks?</strong> Display names (from AT Protocol profile) with nick as subtitle. Users think in terms of identities, not IRC nicks.</p>
</li>
<li><p><strong>Should the app work without JavaScript?</strong> No. This is a WebSocket-based real-time app. Server-rendered fallback would be a different product.</p>
</li>
<li><p><strong>Do we need the edit/delete protocol changes for launch?</strong> Not strictly. Phase 1 can launch without editing. But it&#39;s a glaring gap for Slack refugees. Recommend implementing in Phase 0 alongside msgid.</p>
</li>
<li><p><strong>How do we handle the <code>/</code> command escape hatch?</strong> Show a subtle hint in the compose box: &quot;Type / for commands&quot;. When the user types <code>/</code>, show a command palette overlay (like Discord) with autocomplete. Never require it.</p>
</li>
</ol>
  </div>
</body>
</html>
