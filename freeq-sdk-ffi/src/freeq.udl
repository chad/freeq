namespace freeq {};

dictionary IrcMessage {
    string from_nick;
    string target;
    string text;
    string? msgid;
    string? reply_to;
    string? replaces_msgid;
    string? edit_of;
    string? batch_id;
    boolean is_action;
    i64 timestamp_ms;
};

dictionary IrcMember {
    string nick;
    boolean is_op;
    boolean is_halfop;
    boolean is_voiced;
    string? away_msg;
};

dictionary ChannelTopic {
    string text;
    string? set_by;
};

dictionary TagEntry {
    string key;
    string value;
};

dictionary TagMessage {
    string from;
    string target;
    sequence<TagEntry> tags;
};

[Enum]
interface FreeqEvent {
    Connected();
    Registered(string nick);
    Authenticated(string did);
    AuthFailed(string reason);
    Joined(string channel, string nick);
    Parted(string channel, string nick);
    NickChanged(string old_nick, string new_nick);
    AwayChanged(string nick, string? away_msg);
    Message(IrcMessage msg);
    TagMsg(TagMessage msg);
    Names(string channel, sequence<IrcMember> members);
    TopicChanged(string channel, ChannelTopic topic);
    ModeChanged(string channel, string mode, string? arg, string set_by);
    Kicked(string channel, string nick, string by, string reason);
    UserQuit(string nick, string reason);
    BatchStart(string id, string batch_type, string target);
    BatchEnd(string id);
    Notice(string text);
    Disconnected(string reason);
};

callback interface EventHandler {
    void on_event(FreeqEvent event);
};

interface FreeqClient {
    [Throws=FreeqError]
    constructor(string server, string nick, EventHandler handler);

    [Throws=FreeqError]
    void set_web_token(string token);

    [Throws=FreeqError]
    void set_platform(string platform);

    [Throws=FreeqError]
    void connect();

    void disconnect();

    [Throws=FreeqError]
    void join(string channel);

    [Throws=FreeqError]
    void part(string channel);

    [Throws=FreeqError]
    void send_message(string target, string text);

    [Throws=FreeqError]
    void send_raw(string line);

    [Throws=FreeqError]
    void set_topic(string channel, string topic);

    [Throws=FreeqError]
    void nick(string new_nick);

    boolean is_connected();

    string? current_nick();
};

dictionary PreKeyBundle {
    string identity_key;
    string signed_pre_key;
    string spk_signature;
    u32 spk_id;
};

dictionary SafetyNumber {
    string number;
};

interface FreeqE2ee {
    constructor();

    [Throws=FreeqError]
    PreKeyBundle generate_keys();

    [Throws=FreeqError]
    PreKeyBundle restore_keys(string ik_secret_b64, string spk_secret_b64);

    [Throws=FreeqError]
    sequence<string> export_keys();

    [Throws=FreeqError]
    void establish_session(string remote_did, string their_ik_b64, string their_spk_b64);

    [Throws=FreeqError]
    string encrypt_message(string remote_did, string plaintext);

    [Throws=FreeqError]
    string decrypt_message(string remote_did, string wire);

    boolean has_session(string remote_did);

    boolean is_encrypted(string text);

    [Throws=FreeqError]
    SafetyNumber get_safety_number(string remote_did);

    [Throws=FreeqError]
    string export_session(string remote_did);

    [Throws=FreeqError]
    void import_session(string remote_did, string json);
};

[Error]
enum FreeqError {
    "ConnectionFailed",
    "NotConnected",
    "SendFailed",
    "InvalidArgument",
};
